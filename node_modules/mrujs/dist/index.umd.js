(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.mrujs = {}));
})(this, (function (exports) { 'use strict';

    // Shamelessly stolen from Turbo. Makes the submit event listenable from Safari.
    // https://github.com/hotwired/turbo/blob/main/src/polyfills/submit-event.ts
    const submittersByForm = new WeakMap();
    function findSubmitterFromClickTarget(target) {
        const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
        const candidate = (element != null) ? element.closest('input, button') : null;
        if ((candidate != null) && candidate.type === 'submit') {
            return candidate;
        }
        return null;
    }
    function clickCaptured(event) {
        const submitter = findSubmitterFromClickTarget(event.target);
        if ((submitter === null || submitter === void 0 ? void 0 : submitter.form) != null) {
            submittersByForm.set(submitter.form, submitter);
        }
    }
    (function () {
        let prototype = Event.prototype;
        // Safari 15 has a bug with submitters, this is a check for that.
        const isSafari = navigator.vendor.includes('Apple Computer');
        if ('SubmitEvent' in window) {
            // No need to continue, polyfill not needed. Safari 15 has a bug with submitters.
            if (!isSafari)
                return;
            // We have to attach to the SubmitEvent prototype in Safari instead of Event prototype.
            prototype = window.SubmitEvent.prototype;
        }
        // Polyfill has already been run, do not pass go.
        if ('submitter' in prototype)
            return;
        addEventListener('click', clickCaptured, true);
        Object.defineProperty(prototype, 'submitter', {
            get() {
                if (this.type === 'submit' && this.target instanceof HTMLFormElement) {
                    return submittersByForm.get(this.target);
                }
                return undefined;
            }
        });
    })();

    var _a;
    function toArray(value) {
        if (Array.isArray(value)) {
            return value;
        }
        else if (Array.from != null) {
            return Array.from(value);
        }
        else {
            return [].slice.call(value);
        }
    }
    const m = (_a = Element.prototype.matches) !== null && _a !== void 0 ? _a : Element.prototype.webkitMatchesSelector;
    /**
     * Checks if the given native dom element matches the selector
     * @example
     *   matches(document.querySelector("form"), { selector: "form", exclude: "form[data-remote='true']"})
     *   matches(document.querySelector("form"), "form")
     */
    function matches$1(element, selector) {
        if (!(element instanceof Element)) {
            return false;
        }
        if (typeof selector === 'string') {
            return m.call(element, selector);
        }
        return m.call(element, selector.selector) && !m.call(element, selector.exclude);
    }
    let form = 'form';
    let link = 'a';
    if (window.Turbo != null) {
        form = 'form[data-turbo="false"]';
        link = 'a[data-turbo="false"]';
    }
    const data = 'data-';
    const remote = `${data}remote`;
    const method = `${data}method`;
    const confirm$2 = `${data}confirm`;
    const disable = `${data}disable`;
    const disableWith = `${disable}-with`;
    const BASE_SELECTORS = {
        remoteSelector: `a[${remote}="true"], a[${method}], form[${remote}="true"]`,
        // Link elements bound by rails-ujs
        linkClickSelector: `a[${confirm$2}], ${link}[${method}], ${link}[${remote}]:not([disabled]), ${link}[${disableWith}], ${link}[${disable}]`,
        // Button elements bound by rails-ujs
        buttonClickSelector: {
            selector: `button[${remote}]:not([form]), button[${confirm$2}]:not([form]), button[${disableWith}]:not([form]), button[${disable}]:not([form])`,
            exclude: 'form button'
        },
        // Select elements bound by rails-ujs
        inputChangeSelector: `select[${remote}], input[${remote}], textarea[${remote}]`,
        // Form elements bound by rails-ujs
        formSubmitSelector: `${form}`,
        // Form input elements bound by rails-ujs
        formInputClickSelector: 'form input[type=submit], form input[type=image], form button[type=submit], form button:not([type]), input[type=submit][form], input[type=image][form], button[type=submit][form], button[form]:not([type])',
        // Form input elements disabled during form submission
        formDisableSelector: `input[${disableWith}]:enabled, button[${disableWith}]:enabled, textarea[${disableWith}]:enabled, input[${disable}]:enabled, button[${disable}]:enabled, textarea[${disable}]:enabled`,
        // Form input elements re-enabled after form submission
        formEnableSelector: `input[${disableWith}]:disabled, button[${disableWith}]:disabled, textarea[${disableWith}]:disabled, input[${disable}]:disabled, button[${disable}]:disabled, textarea[${disable}]:disabled`,
        // Link onClick disable selector with possible reenable after remote submission
        linkDisableSelector: `a[${disableWith}], a[${disable}]`,
        // Button onClick disable selector with possible reenable after remote submission
        buttonDisableSelector: `button[data-remote][${disableWith}], button[data-remote][${disable}]`,
        fileInputSelector: 'fileInputSelector: \'input[name][type=file]:not([disabled])\''
    };
    function addListeners(conditions, callbacks) {
        conditions.forEach((condition) => {
            const { selectors, event } = condition;
            const selectorString = selectors.map(selectorToString).join(', ');
            $$1(selectorString).forEach((el) => {
                selectors.forEach((selector) => {
                    if (matches$1(el, selector)) {
                        callbacks.forEach((callback) => el.addEventListener(event, callback));
                    }
                });
            });
        });
    }
    function removeListeners(conditions, callbacks) {
        conditions.forEach((condition) => {
            const { selectors, event } = condition;
            const selectorString = selectors.map(selectorToString).join(', ');
            $$1(selectorString).forEach((el) => {
                selectors.forEach((selector) => {
                    if (matches$1(el, selector)) {
                        callbacks.forEach((callback) => el.removeEventListener(event, callback));
                    }
                });
            });
        });
    }
    function attachObserverCallback(conditions, nodeList, callbacks) {
        conditions.forEach((condition) => {
            condition.selectors.forEach((selector) => {
                nodeList.forEach((node) => {
                    if (matches$1(node, selector)) {
                        callbacks.forEach((cb) => node.addEventListener(condition.event, cb));
                    }
                    if (node instanceof Element) {
                        node.querySelectorAll(selectorToString(selector)).forEach((el) => {
                            callbacks.forEach((cb) => el.addEventListener(condition.event, cb));
                        });
                    }
                });
            });
        });
    }
    /**
     * Helper function that returns form elements that match the specified CSS selector
     *   If form is actually a "form" element this will return associated elements outside the from that have
     *   the html form attribute set
     */
    function formElements$1(form, selector) {
        if (matches$1(form, 'form')) {
            return Array.from(form.elements).filter((el) => matches$1(el, selector));
        }
        return toArray(form.querySelectorAll(selectorToString(selector)));
    }
    function $$1(selector) {
        return toArray((document.querySelectorAll(selector)));
    }
    function selectorToString(selector) {
        let str;
        if (typeof selector === 'string') {
            str = selector;
        }
        else {
            str = selector.selector;
        }
        return str;
    }

    const EVENT_DEFAULTS = {
        bubbles: true,
        cancelable: true
    };
    /**
     * Thin wrapper around element.dispatchEvent and new CustomEvent
     */
    function dispatch(name, options = {}) {
        const event = new CustomEvent(name, { ...EVENT_DEFAULTS, ...options });
        this.dispatchEvent(event);
        return event;
    }
    /**
     * Backwards compatibility function that hooks into dispatch.
     */
    function fire$1(element, name, options = {}) {
        const event = dispatch.call(element, name, options);
        return !event.defaultPrevented;
    }
    function stopEverything$1(event) {
        if (event.target != null)
            fire$1(event.target, 'ujs:everythingStopped');
        event.stopPropagation();
        event.stopImmediatePropagation();
        event.preventDefault();
    }
    const prefix = 'ajax';
    const AJAX_EVENTS = {
        /**
         * Before the ajax event gets sent.
         * You can view what data will be sent via: `event.detail.formData`
         */
        ajaxBefore: `${prefix}:before`,
        /**
         * Just prior to sending the fetch request
         */
        ajaxBeforeSend: `${prefix}:beforeSend`,
        /**
         * When the fetch request is sent. You can view whats being sent via:
         * `event.detail.formData`
         */
        ajaxSend: `${prefix}:send`,
        /**
         * When a response error occurs. IE: 400, 404, 422, 500, etc (any status code not between 200 - 299)
         * The response error can be viewed via: `event.detail.response`
         */
        ajaxResponseError: `${prefix}:response:error`,
        /**
         * Catches errors with requests such as Network errors.
         */
        ajaxRequestError: `${prefix}:request:error`,
        /**
         * When a >= 200 and <= 299 response is returned
         * You can view the full response via: `event.detail.response`
         */
        ajaxSuccess: `${prefix}:success`,
        /**
         * A unified event to catch both Response and Request errors.
         * You can view the error via: `event.detail.error`
         * This will also generate an error in your console.log
         */
        ajaxError: `${prefix}:error`,
        /**
         * After any fetch request, regardless of outcome
         * Does not have any accessible data besides the event itself
         */
        ajaxComplete: `${prefix}:complete`,
        ajaxStopped: `${prefix}:stopped`,
        ajaxBeforeNavigation: `${prefix}:beforeNavigation`
        // NOT CURRENTLY IMPLEMENTED
        // /**
        //  * when there are blank required fields in a form, submits anyway if stopped
        //  */
        // ajaxAbortedRequired: `${prefix}:aborted:required`,
        // /**
        //  * if there are non-blank input:file fields in a form, aborts if stopped
        //  */
        // ajaxAbortedFile: `${prefix}:aborted:file`
    };
    /**
     * Delegates events
     * to a specified parent `element`, which fires event `handler`
     * for the specified `selector` when an event of `eventType` is triggered
     * element::
     *   parent element that will listen for events e.g. document
     * selector::
     *   css selector; or an object that has `selector` and `exclude` properties (see: Rails.matches)
     * eventType::
     *   string representing the event e.g. 'submit', 'click'
     * handler::
     *   the event handler to be called
     */
    function delegate$1(element, selector, eventType, handler) {
        element.addEventListener(eventType, (event) => {
            let target = event.target;
            while (!(!(target instanceof Element) || matches$1(target, selector))) {
                target = target.parentNode;
            }
            if (target instanceof Element && handler.call(target, event) === false) {
                event.preventDefault();
                event.stopPropagation();
            }
        });
    }

    function findSubmitter(event) {
        var _a;
        // Not supported by webkit
        if (event.submitter instanceof HTMLElement) {
            return event.submitter;
        }
        // we have a polyfill that adds submitter on event.detail
        return (_a = event.detail) === null || _a === void 0 ? void 0 : _a.submitter;
    }

    function expandUrl(locateable) {
        return new URL(locateable.toString(), document.baseURI);
    }
    function urlsAreEqual(left, right) {
        return expandUrl(left).href === expandUrl(right).href;
    }
    function mergeHeaders(...sources) {
        const main = {};
        for (const source of sources) {
            for (const [header, value] of source) {
                main[header] = value;
            }
        }
        return new Headers(main);
    }
    function isGetRequest(method) {
        return method.toLowerCase() === 'get';
    }

    // Shamelessly stolen from Turbo.
    // https://github.com/hotwired/turbo/blob/main/src/http/fetch_response.ts
    function FetchResponse$1(response) {
        let _text;
        let _json;
        const succeeded = response.ok;
        const status = response.status;
        const failed = !succeeded;
        const clientError = (response.status >= 400 && response.status <= 499);
        const serverError = (response.status >= 500 && response.status <= 599);
        const redirected = response.redirected;
        const location = expandUrl(response.url);
        const contentType = getHeader('content-type');
        const isHtml = Boolean(contentType === null || contentType === void 0 ? void 0 : contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/));
        const isJson = Boolean(contentType === null || contentType === void 0 ? void 0 : contentType.toLowerCase().match(/(^application\/json|\.json)/));
        async function text() {
            if (_text != null)
                return _text;
            _text = await response.clone().text();
            return _text;
        }
        async function html() {
            if (isHtml)
                return await text();
            return await Promise.reject(response);
        }
        async function json() {
            if (isJson) {
                if (_json != null)
                    return _json;
                _json = JSON.parse(await text());
                return _json;
            }
            return await Promise.reject(response);
        }
        function getHeader(name) {
            return response.headers.get(name);
        }
        return {
            succeeded,
            failed,
            redirected,
            clientError,
            serverError,
            location,
            contentType,
            getHeader,
            isHtml,
            isJson,
            text,
            html,
            json,
            response,
            status
        };
    }

    function buildFormElementFormData(element, submitter) {
        const formData = new FormData(element);
        let name;
        let value;
        if (submitter != null) {
            name = submitter.getAttribute('name');
            value = submitter.getAttribute('value');
        }
        if (name != null && value != null && formData.get(name) !== value) {
            formData.append(name, value);
        }
        return formData;
    }
    const FormEncTypes = {
        urlEncoded: 'application/x-www-form-urlencoded',
        multipart: 'multipart/form-data',
        plain: 'text/plain'
    };
    function formEnctypeFromString(encoding) {
        switch (encoding.toLowerCase()) {
            case FormEncTypes.multipart: return FormEncTypes.multipart;
            case FormEncTypes.plain: return FormEncTypes.plain;
            default: return FormEncTypes.urlEncoded;
        }
    }
    function formDataToStrings(formData) {
        return [...formData].reduce((entries, [name, value]) => {
            return entries.concat(typeof value === 'string' ? [[name, value]] : []);
        }, []);
    }
    function urlEncodeFormData(formData) {
        return new URLSearchParams(formDataToStrings(formData));
    }

    const BASE_ACCEPT_HEADERS = {
        '*': '*/*',
        any: '*/*',
        text: 'text/plain',
        html: 'text/html',
        xml: 'application/xml, text/xml',
        json: 'application/json, text/javascript',
        script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript'
    };
    function findResponseTypeHeader(responseType) {
        var _a, _b, _c;
        const mimeTypes = (_b = (_a = window.mrujs) === null || _a === void 0 ? void 0 : _a.mimeTypes) !== null && _b !== void 0 ? _b : BASE_ACCEPT_HEADERS;
        const acceptHeaders = {
            ...mimeTypes
        };
        if (responseType == null) {
            return (_c = acceptHeaders === null || acceptHeaders === void 0 ? void 0 : acceptHeaders.any) !== null && _c !== void 0 ? _c : '*/*';
        }
        responseType = responseType.trim();
        if ((acceptHeaders != null) && Object.keys(acceptHeaders).includes(responseType)) {
            responseType = acceptHeaders[responseType];
        }
        if (responseType.includes('*/*'))
            return responseType;
        return `${responseType}, */*; q=0.01`;
    }

    function isInsignificantClick(event) {
        return (((event.target != null) && event.target.isContentEditable) ||
            event.defaultPrevented ||
            event.button > 0 || // Only left clicks!
            event.altKey ||
            event.ctrlKey ||
            event.metaKey ||
            event.shiftKey);
    }
    function isSignificantClick(event) {
        return !isInsignificantClick(event);
    }
    function preventInsignificantClick$1(event) {
        if (isSignificantClick(event))
            return;
        stopEverything$1(event);
    }
    function getCookieValue(cookieName) {
        if (cookieName != null) {
            const cookies = document.cookie.trim() !== '' ? document.cookie.split('; ') : [];
            const cookie = cookies.find((cookie) => cookie.startsWith(cookieName));
            if (cookie != null) {
                const value = cookie.split('=').slice(1).join('=');
                return (value.trim() !== '' ? decodeURIComponent(value) : undefined);
            }
        }
        return undefined;
    }
    function getMetaContent(str) {
        var _a;
        const elements = $$1(`meta[name="${str}"]`);
        const element = elements[elements.length - 1];
        return (_a = element === null || element === void 0 ? void 0 : element.content) !== null && _a !== void 0 ? _a : undefined;
    }

    // https://github.com/rails/rails/blob/main/actionview/app/assets/javascripts/rails-ujs/utils/csrf.coffee
    function Csrf() {
        return {
            name: 'Csrf',
            connect: connect$3,
            disconnect: disconnect$3,
            observerCallback
        };
    }
    function connect$3() {
        refreshCSRFTokens$1();
    }
    function disconnect$3() { }
    function observerCallback(nodeList) {
        for (let i = 0; i < nodeList.length; i++) {
            const node = nodeList[i];
            if (isCsrfToken(node)) {
                refreshCSRFTokens$1();
            }
        }
    }
    // Make sure that all forms have actual up-to-date tokens (cached forms contain old ones)
    function refreshCSRFTokens$1() {
        const token = csrfToken$1();
        const param = csrfParam$1();
        if (token != null && param != null) {
            $$1(`form input[name="${param}"]`).forEach(input => {
                const inputEl = input;
                inputEl.value = token;
            });
        }
    }
    function isCsrfToken(node) {
        if (node instanceof HTMLMetaElement) {
            return node.matches('meta[name="csrf-token]"');
        }
        return false;
    }
    // Up-to-date Cross-Site Request Forgery token
    function csrfToken$1() {
        var _a;
        return (_a = getCookieValue(csrfParam$1())) !== null && _a !== void 0 ? _a : getMetaContent('csrf-token');
    }
    // URL param that must contain the CSRF token
    function csrfParam$1() {
        return getMetaContent('csrf-param');
    }
    function CSRFProtection$1(request) {
        const token = csrfToken$1();
        const str = 'X-CSRF-TOKEN';
        if (token != null && request.headers.get(str) == null)
            request.headers.set('X-CSRF-TOKEN', token);
    }

    /**
     * Fetch Request is essentially an "proxy" class meant to wrap a standard Request
     *   Object and provide some sane convetions like passing in an abort controller,
     *   auto-serialization of FormData, auto-filling X-CSRF-Token and a number of other
     *   niceties. The FetchRequest constructor follows the same conventions as fetch.
     *   It can either take in a Request object, or be giving a url and then an object
     *   with all the fetch options.
     */
    function FetchRequest$1(input, options = {}) {
        const abortController = new AbortController();
        const abortSignal = abortController.signal;
        let headers;
        let url;
        let method = 'get';
        let request;
        let _isGetRequest = false;
        method = getMethod$1(options);
        _isGetRequest = isGetRequest(method);
        const body = getBody$2(options);
        if (input instanceof Request) {
            url = getUrl(input.url, _isGetRequest, body);
            request = createRequestFromRequest(input);
        }
        else {
            url = getUrl(input, _isGetRequest, body);
            request = createRequestFromLocateable();
        }
        if (!_isGetRequest)
            CSRFProtection$1(request);
        headers = request.headers;
        const params = url.searchParams;
        return {
            request,
            method,
            url,
            body,
            params,
            abortController,
            abortSignal,
            cancel,
            headers,
            isGetRequest: _isGetRequest
        };
        function defaultHeaders() {
            const headers = new Headers({
                Accept: '*/*',
                'X-REQUESTED-WITH': 'XmlHttpRequest'
            });
            return headers;
        }
        function cancel(event) {
            abortController.abort();
            // trigger event dispatching if an event gets passed in.
            if (event != null) {
                stopEverything$1(event);
                const { element } = event.detail;
                dispatch.call(element, AJAX_EVENTS.ajaxStopped, {
                    detail: { ...event.detail }
                });
            }
        }
        function createRequestFromRequest(input) {
            headers = mergeHeaders(defaultHeaders(), input.headers);
            const mergedOptions = { ...defaultRequestOptions(), ...input };
            // @ts-expect-error
            if (_isGetRequest)
                delete mergedOptions.body;
            // @ts-expect-error this.url is really a URL, but typescript seems to think Request cant handle it.
            return new Request(url, mergedOptions);
        }
        function createRequestFromLocateable() {
            headers = mergeHeaders(defaultHeaders(), new Headers(options.headers));
            const mergedOptions = { ...defaultRequestOptions(), ...options };
            mergedOptions.headers = headers;
            if (_isGetRequest)
                delete mergedOptions.body;
            // @ts-expect-error this.url is really a URL, but typescript seems to think Request cant handle it.
            return new Request(url, mergedOptions);
        }
        function defaultRequestOptions() {
            const options = {
                method,
                headers,
                credentials: 'same-origin',
                redirect: 'follow',
                signal: abortSignal
            };
            if (_isGetRequest) {
                return options;
            }
            options.body = body;
            return options;
        }
    }
    function getUrl(url, getRequest, body) {
        const location = expandUrl(url);
        if (!getRequest)
            return location;
        // Append params to the Url.
        return mergeFormDataEntries(location, entries(body));
    }
    function entries(body) {
        return body instanceof URLSearchParams ? Array.from(body.entries()) : [];
    }
    function getBody$2(input) {
        var _a;
        return ((_a = input.body) !== null && _a !== void 0 ? _a : new URLSearchParams());
    }
    function getMethod$1(input) {
        var _a, _b;
        return ((_b = (_a = input.method) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : 'get');
    }
    function mergeFormDataEntries(url, entries) {
        const currentSearchParams = new URLSearchParams(url.search);
        for (const [name, value] of entries) {
            if (value instanceof File)
                continue;
            // Only happens on GET requests, not needed.
            if (name === 'authenticity_token')
                continue;
            if (currentSearchParams.has(name)) {
                currentSearchParams.delete(name);
                url.searchParams.set(name, value);
            }
            else {
                url.searchParams.append(name, value);
            }
        }
        return url;
    }

    /**
     * This handles FormSubmissions on forms that use data-remote="true"
     * This should not be interacted with directly and instead is merely meant for
     * connecting to the DOM.
     */
    function FormSubmission(element, submitter) {
        const url = expandUrl(getAction(element, submitter));
        const options = getOptions(element, submitter);
        const fetchRequest = FetchRequest$1(url, options);
        const request = fetchRequest.request;
        return {
            fetchRequest,
            request,
            element,
            submitter
        };
    }
    function getOptions(element, submitter) {
        const method = getMethod(element, submitter);
        const headers = getHeaders$1(element);
        const options = {
            method,
            headers
        };
        // Will get stripped out by FetchRequest if its a GET request.
        options.body = getBody$1(element, method, submitter);
        return options;
    }
    /**
      * Headers to send to the request object
      */
    function getHeaders$1(element) {
        let responseType;
        if (element != null) {
            responseType = element.dataset.type;
        }
        const acceptHeader = findResponseTypeHeader(responseType);
        const headers = new Headers({ Accept: acceptHeader });
        headers.set('Accept', acceptHeader);
        return headers;
    }
    /**
      * Returns properly built FormData
      */
    function getFormData$1(element, submitter) {
        return buildFormElementFormData(element, submitter);
    }
    /**
      * Finds how to send the fetch request
      * get, post, put, patch, etc
      */
    function getMethod(element, submitter) {
        var _a, _b;
        const method = (_b = (_a = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute('formmethod')) !== null && _a !== void 0 ? _a : element.getAttribute('method')) !== null && _b !== void 0 ? _b : 'get';
        return method.toLowerCase();
    }
    function getAction(element, submitter) {
        var _a, _b;
        const action = (_b = (_a = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute('formaction')) !== null && _a !== void 0 ? _a : element.getAttribute('action')) !== null && _b !== void 0 ? _b : '';
        return action;
    }
    function getBody$1(element, method, submitter) {
        const formData = getFormData$1(element, submitter);
        if (getEncType(element, submitter) === FormEncTypes.urlEncoded || (isGetRequest(method))) {
            return urlEncodeFormData(formData);
        }
        else {
            return formData;
        }
    }
    function getEncType(element, submitter) {
        var _a, _b;
        const elementEncType = element.getAttribute('enctype');
        const encType = (_b = (_a = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute('formenctype')) !== null && _a !== void 0 ? _a : elementEncType) !== null && _b !== void 0 ? _b : FormEncTypes.urlEncoded;
        const encString = formEnctypeFromString(encType);
        return encString;
    }

    function ElementDisabler() {
        const callbacks = [disableElement$1];
        let queries = [];
        function initialize() {
            queries = getQueries$5();
        }
        function connect() {
            addListeners(queries, callbacks);
        }
        function disconnect() {
            removeListeners(queries, callbacks);
        }
        function observerCallback(nodeList) {
            attachObserverCallback(queries, nodeList, callbacks);
        }
        return {
            name: 'ElementDisabler',
            initialize,
            connect,
            disconnect,
            observerCallback,
            queries
        };
    }
    function getQueries$5() {
        const { formSubmitSelector, linkClickSelector, buttonClickSelector, inputChangeSelector } = window.mrujs;
        return [
            { event: 'click', selectors: [buttonClickSelector, linkClickSelector] },
            { event: 'ajax:send', selectors: [formSubmitSelector] },
            { event: 'turbo:submit-start', selectors: ['form'] },
            { event: 'change', selectors: [inputChangeSelector] }
        ];
    }
    /**
      * Unified function to disable an element (link, button and form)
      */
    function disableElement$1(event) {
        let element;
        if (event instanceof Event) {
            element = event.target;
        }
        else {
            element = event;
        }
        if (element == null)
            return;
        const { linkDisableSelector, buttonDisableSelector, formDisableSelector, formSubmitSelector } = window.mrujs;
        if (matches$1(element, linkDisableSelector)) {
            disableLinkElement(element);
        }
        else if (matches$1(element, buttonDisableSelector) || matches$1(element, formDisableSelector)) {
            disableFormElement(element);
        }
        else if (matches$1(element, formSubmitSelector)) {
            disableFormElements(element);
        }
    }
    /**
      * Disables form elements:
      *   - Caches element value in 'ujs-enable-with' data store
      *   - Replaces element text with value of 'data-disable-with' attribute
      *   - Sets disabled property to true
      */
    function disableFormElements(form) {
        formElements$1(form, window.mrujs.formDisableSelector).forEach((el) => disableFormElement(el));
    }
    function disableFormElement(element) {
        if (element.dataset.ujsDisabled != null)
            return;
        const replacement = element.getAttribute('data-disable-with');
        if (replacement != null) {
            if (matches$1(element, 'button')) {
                element.dataset.ujsEnableWith = element.innerHTML;
                element.innerHTML = replacement;
            }
            else {
                element.dataset.ujsEnableWith = element.value;
                element.value = replacement;
            }
        }
        element.dataset.ujsDisabled = 'true';
        // Due to how FormSubmissions work in Chrome, if the button is disabled prior
        // to submitting the form, then form "submit" event will never trigger.
        setTimeout(() => { element.disabled = true; });
    }
    /**
      * Replace element's html with the 'data-disable-with' after storing original html
      *   and prevent clicking on it
      */
    function disableLinkElement(element) {
        if (element.dataset.ujsDisabled != null)
            return;
        const replacement = element.dataset.disableWith;
        // Perhaps morph here instead??
        if (replacement != null) {
            element.dataset.ujsEnableWith = element.innerHTML;
            element.innerHTML = replacement;
        }
        element.addEventListener('click', stopEverything$1); // prevent further clicking
        element.dataset.ujsDisabled = 'true';
    }

    function FormSubmitDispatcher() {
        return {
            name: 'FormSubmitDispatcher',
            connect: connect$2,
            disconnect: disconnect$2
        };
    }
    function connect$2() {
        attachListeners('addEventListener');
    }
    function disconnect$2() {
        attachListeners('removeEventListener');
    }
    /**
      * Basic fetch request which leverages the FetchRequest object.
      *   This is an internal fetch
      *   Appropriate headers will be set for you but can be overriden.
      * @fires `ajax:before`
      */
    function startFormSubmission(event) {
        if (event.defaultPrevented) {
            return;
        }
        // If it doesnt have remote="true"...forget about it!
        const element = findTarget(event);
        const submitter = findSubmitter(event);
        if (element.dataset.remote !== 'true')
            return;
        if (shouldNotSubmit(element))
            return;
        if (shouldNotSubmit(submitter))
            return;
        if (submitter != null) {
            disableElement$1(submitter);
        }
        event.preventDefault();
        const { fetchRequest, request } = FormSubmission(element, submitter);
        const detail = { element, fetchRequest, request, submitter };
        dispatch.call(element, AJAX_EVENTS.ajaxBefore, { detail });
    }
    /**
      * Fires off a fetch request and returns the response data. Triggered by events.
      * @fires `ajax:beforeSend`
      * The request can be found via `event.detail.request`
      */
    function startFetchRequest(event) {
        const { element, fetchRequest, request, submitter } = event.detail;
        if (event.defaultPrevented || shouldNotSubmit(element) || shouldNotSubmit(submitter)) {
            dispatchStopped(event);
            return;
        }
        dispatch.call(element, AJAX_EVENTS.ajaxBeforeSend, {
            detail: { element, fetchRequest, request, submitter }
        });
    }
    function sendFetchRequest(event) {
        const { element, request, submitter } = event.detail;
        if (event.defaultPrevented || shouldNotSubmit(element) || shouldNotSubmit(submitter)) {
            dispatchStopped(event);
            return;
        }
        dispatch.call(element, AJAX_EVENTS.ajaxSend, { detail: { ...event.detail } });
        window.fetch(request).then((resp) => {
            const fetchResponse = FetchResponse$1(resp);
            const { response } = fetchResponse;
            dispatchResponse({ ...event.detail, fetchResponse, response });
        }).catch((error) => dispatchRequestError({ ...event.detail, error }));
    }
    /**
      * Handles FetchResponses
      *   Fires `ajax:response:error` or `ajax:success` depending on the response.
      *   You can find the response in `event.detail.response`

    /*
      * Dispatches the `ajax:complete` event.
      * { response, request?, error?, submitter } = detail
      */
    function dispatchComplete(event) {
        if (event.defaultPrevented) {
            dispatchStopped(event);
            return;
        }
        dispatch.call(findTarget(event), AJAX_EVENTS.ajaxComplete, {
            detail: { ...event.detail }
        });
    }
    /**
      * Handles FetchResponses
      * @fires `ajax:response:error` or `ajax:success` depending on if the response succeeded.
      * properties: { request, response, submitter } = event.detail
      */
    function dispatchResponse({ element, fetchRequest, request, fetchResponse, response, submitter }) {
        const status = response === null || response === void 0 ? void 0 : response.status;
        if ((fetchResponse === null || fetchResponse === void 0 ? void 0 : fetchResponse.succeeded) === true) {
            dispatch.call(element, AJAX_EVENTS.ajaxSuccess, {
                detail: { element, fetchRequest, request, fetchResponse, response, submitter, status }
            });
            return;
        }
        // Response errors, >= 400 responses
        dispatch.call(element, AJAX_EVENTS.ajaxResponseError, {
            detail: { element, fetchRequest, request, fetchResponse, response, submitter, status }
        });
    }
    /**
      * Handles a `fetch()` request error.
      * @fires `ajax:request:error`
      * properties: `{ request, error, submitter } = event.detail`
      */
    function dispatchRequestError({ element, fetchRequest, request, error, submitter }) {
        dispatch.call(element, AJAX_EVENTS.ajaxRequestError, {
            detail: { element, fetchRequest, request, error, submitter }
        });
    }
    /**
      * @fires the `ajax:error` event which is a catchall for request + response errors.
      * { response, request?, error?, submitter } = event.detail
      */
    function dispatchError(event) {
        if (event.defaultPrevented) {
            dispatchStopped(event);
            return;
        }
        dispatch.call(findTarget(event), AJAX_EVENTS.ajaxError, {
            detail: { ...event.detail }
        });
    }
    // This is only for when event.defaultPrevented() is called.
    // if a user calls `event.detail.submission.cancel()`, that will be triggered separately.
    function dispatchStopped(event) {
        dispatch.call(findTarget(event), AJAX_EVENTS.ajaxStopped, {
            detail: { ...event.detail }
        });
    }
    /**
      * dispatches a given event in the context of `element`
      */
    function attachListeners(fn) {
        document[fn]('submit', startFormSubmission); // fires ajaxBefore
        document[fn](AJAX_EVENTS.ajaxBefore, startFetchRequest); // fires ajaxBeforeSend
        // fires ajaxRequestError || ajaxSuccess || ajaxResponse
        document[fn](AJAX_EVENTS.ajaxBeforeSend, sendFetchRequest);
        document[fn](AJAX_EVENTS.ajaxSuccess, dispatchComplete);
        document[fn](AJAX_EVENTS.ajaxRequestError, dispatchError);
        document[fn](AJAX_EVENTS.ajaxResponseError, dispatchError);
        document[fn](AJAX_EVENTS.ajaxError, dispatchComplete);
    }
    function findTarget(event) {
        return event.target;
    }
    function shouldNotSubmit(element) {
        return (element === null || element === void 0 ? void 0 : element.dataset.ujsSubmit) === 'false';
    }

    function RemoteWatcher() {
        let query;
        function initialize() {
            query = window.mrujs.remoteSelector;
        }
        function connect() {
            $$1(query).forEach((el) => {
                addTurboFalse(el);
            });
        }
        function disconnect() { }
        function observerCallback(nodeList) {
            nodeList.forEach((node) => {
                if (matches$1(node, window.mrujs.remoteSelector)) {
                    addTurboFalse(node);
                }
                if (node instanceof Element) {
                    node.querySelectorAll(query).forEach((el) => {
                        addTurboFalse(el);
                    });
                }
            });
        }
        return {
            name: 'RemoteWatcher',
            initialize,
            connect,
            disconnect,
            observerCallback
        };
    }
    function addTurboFalse(el) {
        if (el == null)
            return;
        if (el.getAttribute('data-turbo') != null)
            return;
        el.setAttribute('data-turbo', 'false');
    }

    function ClickHandler() {
        const callbacks = [preventInsignificantClick$1];
        let queries = [];
        function initialize() {
            queries = getQueries$4();
        }
        function connect() {
            addListeners(queries, callbacks);
        }
        function disconnect() {
            removeListeners(queries, callbacks);
        }
        function observerCallback(nodeList) {
            attachObserverCallback(queries, nodeList, callbacks);
        }
        return {
            name: 'ClickHandler',
            initialize,
            connect,
            disconnect,
            observerCallback,
            queries,
            callbacks
        };
    }
    function getQueries$4() {
        const { linkClickSelector, buttonClickSelector, formInputClickSelector } = window.mrujs;
        return [
            {
                event: 'click',
                selectors: [
                    linkClickSelector,
                    buttonClickSelector,
                    formInputClickSelector
                ]
            }
        ];
    }

    function Confirm() {
        const callbacks = [handleConfirm$1];
        let queries = [];
        function initialize() {
            queries = getQueries$3();
        }
        function connect() {
            addListeners(queries, callbacks);
        }
        function disconnect() {
            removeListeners(queries, callbacks);
        }
        function observerCallback(nodeList) {
            attachObserverCallback(queries, nodeList, callbacks);
        }
        return {
            name: 'Confirm',
            initialize,
            connect,
            disconnect,
            observerCallback,
            queries,
            callbacks
        };
    }
    function handleConfirm$1(event) {
        if (!allowAction(event)) {
            stopEverything$1(event);
        }
    }
    function allowAction(event) {
        if (event.currentTarget == null)
            return true;
        const element = event.currentTarget;
        const message = element.dataset.confirm;
        if (message == null)
            return true;
        let answer = false;
        try {
            answer = window.mrujs.confirm(message);
        }
        catch (e) {
            console.warn('The following error was encountered when calling: "mrujs.confirm"\n\n');
            console.error(e);
        }
        const firedEvent = dispatch.call(element, 'confirm:complete', { detail: { answer } });
        return answer && !firedEvent.defaultPrevented;
    }
    function getQueries$3() {
        const { linkClickSelector, buttonClickSelector, formInputClickSelector, inputChangeSelector, formSubmitSelector } = window.mrujs;
        return [
            {
                event: 'click',
                selectors: [
                    linkClickSelector,
                    buttonClickSelector,
                    formInputClickSelector
                ]
            },
            {
                event: 'change',
                selectors: [
                    inputChangeSelector
                ]
            },
            {
                event: 'submit',
                selectors: [
                    formSubmitSelector
                ]
            }
        ];
    }

    /**
     * This class handles data-method / data-remote submissions (<a data-remote"true">)
      */
    function MethodSubmission(element) {
        var _a, _b;
        const method = getElementMethod(element);
        let maskedMethod;
        if ((_a = window.mrujs) === null || _a === void 0 ? void 0 : _a.maskLinkMethods) {
            maskedMethod = getMaskedMethod(method);
        }
        const href = (_b = element.getAttribute('href')) !== null && _b !== void 0 ? _b : element.dataset.url;
        if (href == null) {
            throw Error(`No 'href' or 'data-url' found on ${JSON.stringify(element)}`);
        }
        const url = expandUrl(href);
        const options = {
            headers: getHeaders(element)
        };
        options.method = maskedMethod !== null && maskedMethod !== void 0 ? maskedMethod : method;
        if (!isGetRequest(method))
            options.body = getBody(method, element);
        const fetchRequest = FetchRequest$1(url, options);
        return {
            request: fetchRequest.request,
            fetchRequest
        };
    }
    /**
     * Headers to send to the request object
     */
    function getHeaders(element) {
        let responseType;
        if (element != null) {
            responseType = element.dataset.type;
        }
        const acceptHeader = findResponseTypeHeader(responseType);
        const headers = new Headers({ Accept: acceptHeader });
        headers.set('Accept', acceptHeader);
        return headers;
    }
    /**
      * Returns properly built FormData
      */
    function getFormData(method) {
        var _a;
        const formData = new FormData();
        if ((_a = window.mrujs) === null || _a === void 0 ? void 0 : _a.maskLinkMethods) {
            formData.append('_method', method);
        }
        return formData;
    }
    /**
      * Finds how to send the fetch request
      * get, post, put, patch, etc
      */
    function getElementMethod(element) {
        var _a;
        const method = (_a = element.dataset.method) !== null && _a !== void 0 ? _a : 'get';
        return method.toLowerCase();
    }
    /**
      * If its a get request, leave it, everything else is masked as a POST.
      */
    function getMaskedMethod(method) {
        return isGetRequest(method) ? 'get' : 'post';
    }
    function getBody(method, element) {
        const encodedFormData = urlEncodeFormData(getFormData(method));
        // add input's name and value to submission
        const elName = element.getAttribute('name');
        // cast to HTMLInputElement to make TS happy.
        const elValue = element.value;
        if (elName != null && elValue != null)
            encodedFormData.append(elName, elValue);
        const additionalParams = parseParams(element.getAttribute('data-params'));
        if (additionalParams == null)
            return encodedFormData;
        for (const [key, value] of additionalParams) {
            if (value == null)
                continue;
            const val = value.toString();
            // Only strings can be added to UrlSearchParams
            const isString = (typeof val === 'string' || val instanceof String);
            if (!isString)
                continue;
            encodedFormData.append(key, val.toString());
        }
        return encodedFormData;
    }
    function parseParams(params) {
        if (params == null)
            return undefined;
        // convert encoded params to decoded params
        if (containsEncodedComponents(params)) {
            params = decodeURIComponent(params);
        }
        // json format
        try {
            return Object.entries(JSON.parse(params));
        }
        catch (_a) { }
        // param string format
        try {
            return new URLSearchParams(params).entries();
        }
        catch (_b) { }
        return undefined;
    }
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent
    function containsEncodedComponents(x) {
        // ie ?,=,&,/ etc
        return (decodeURI(x) !== decodeURIComponent(x));
    }

    /**
     * Handles `data-method="method"` submissions.
     */
    function Method() {
        const callbacks = [handleMethod$1];
        let queries = [];
        function initialize() {
            queries = getQueries$2();
        }
        function connect() {
            addListeners(queries, callbacks);
        }
        function disconnect() {
            removeListeners(queries, callbacks);
        }
        function observerCallback(nodeList) {
            attachObserverCallback(queries, nodeList, callbacks);
        }
        return {
            name: 'Method',
            initialize,
            connect,
            disconnect,
            observerCallback,
            queries,
            callbacks
        };
    }
    /**
      * Handles "data-method" on <a> tags such as:
      * @example
      *   // Not implemented!
      *   <a href="/users/5" data-method="delete" rel="nofollow" data-confirm="Are you sure?">Delete</a>
      *
      *   // Implemented!
      *   <a href="/users/5" data-method="delete" rel="nofollow">Delete</a>
      */
    function handleMethod$1(event) {
        var _a;
        const element = event.currentTarget;
        if (element.dataset.remote === 'false')
            return;
        if (element.dataset.method == null && element.dataset.remote !== 'true')
            return;
        // no href or url? Do not pass go.
        const href = (_a = element.getAttribute('href')) !== null && _a !== void 0 ? _a : element.dataset.url;
        if (href == null)
            return;
        event.preventDefault();
        const submitter = event.target;
        const linkSubmission = MethodSubmission(element);
        const { fetchRequest, request } = linkSubmission;
        /**
          * Send it through the event chain. use ajax:beforeSend because submit auto
          * populates fields that we dont want.
          */
        dispatch.call(element, AJAX_EVENTS.ajaxBeforeSend, {
            detail: { element, fetchRequest, request, submitter }
        });
    }
    function getQueries$2() {
        const { linkClickSelector, inputChangeSelector, buttonClickSelector } = window.mrujs;
        return [
            {
                event: 'click',
                selectors: [
                    linkClickSelector,
                    buttonClickSelector
                ]
            },
            {
                event: 'change',
                selectors: [
                    inputChangeSelector
                ]
            }
        ];
    }

    var DOCUMENT_FRAGMENT_NODE = 11;

    function morphAttrs(fromNode, toNode) {
        var toNodeAttrs = toNode.attributes;
        var attr;
        var attrName;
        var attrNamespaceURI;
        var attrValue;
        var fromValue;

        // document-fragments dont have attributes so lets not do anything
        if (toNode.nodeType === DOCUMENT_FRAGMENT_NODE || fromNode.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return;
        }

        // update attributes on original DOM element
        for (var i = toNodeAttrs.length - 1; i >= 0; i--) {
            attr = toNodeAttrs[i];
            attrName = attr.name;
            attrNamespaceURI = attr.namespaceURI;
            attrValue = attr.value;

            if (attrNamespaceURI) {
                attrName = attr.localName || attrName;
                fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);

                if (fromValue !== attrValue) {
                    if (attr.prefix === 'xmlns'){
                        attrName = attr.name; // It's not allowed to set an attribute with the XMLNS namespace without specifying the `xmlns` prefix
                    }
                    fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);
                }
            } else {
                fromValue = fromNode.getAttribute(attrName);

                if (fromValue !== attrValue) {
                    fromNode.setAttribute(attrName, attrValue);
                }
            }
        }

        // Remove any extra attributes found on the original DOM element that
        // weren't found on the target element.
        var fromNodeAttrs = fromNode.attributes;

        for (var d = fromNodeAttrs.length - 1; d >= 0; d--) {
            attr = fromNodeAttrs[d];
            attrName = attr.name;
            attrNamespaceURI = attr.namespaceURI;

            if (attrNamespaceURI) {
                attrName = attr.localName || attrName;

                if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {
                    fromNode.removeAttributeNS(attrNamespaceURI, attrName);
                }
            } else {
                if (!toNode.hasAttribute(attrName)) {
                    fromNode.removeAttribute(attrName);
                }
            }
        }
    }

    var range; // Create a range object for efficently rendering strings to elements.
    var NS_XHTML = 'http://www.w3.org/1999/xhtml';

    var doc = typeof document === 'undefined' ? undefined : document;
    var HAS_TEMPLATE_SUPPORT = !!doc && 'content' in doc.createElement('template');
    var HAS_RANGE_SUPPORT = !!doc && doc.createRange && 'createContextualFragment' in doc.createRange();

    function createFragmentFromTemplate(str) {
        var template = doc.createElement('template');
        template.innerHTML = str;
        return template.content.childNodes[0];
    }

    function createFragmentFromRange(str) {
        if (!range) {
            range = doc.createRange();
            range.selectNode(doc.body);
        }

        var fragment = range.createContextualFragment(str);
        return fragment.childNodes[0];
    }

    function createFragmentFromWrap(str) {
        var fragment = doc.createElement('body');
        fragment.innerHTML = str;
        return fragment.childNodes[0];
    }

    /**
     * This is about the same
     * var html = new DOMParser().parseFromString(str, 'text/html');
     * return html.body.firstChild;
     *
     * @method toElement
     * @param {String} str
     */
    function toElement(str) {
        str = str.trim();
        if (HAS_TEMPLATE_SUPPORT) {
          // avoid restrictions on content for things like `<tr><th>Hi</th></tr>` which
          // createContextualFragment doesn't support
          // <template> support not available in IE
          return createFragmentFromTemplate(str);
        } else if (HAS_RANGE_SUPPORT) {
          return createFragmentFromRange(str);
        }

        return createFragmentFromWrap(str);
    }

    /**
     * Returns true if two node's names are the same.
     *
     * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same
     *       nodeName and different namespace URIs.
     *
     * @param {Element} a
     * @param {Element} b The target element
     * @return {boolean}
     */
    function compareNodeNames(fromEl, toEl) {
        var fromNodeName = fromEl.nodeName;
        var toNodeName = toEl.nodeName;
        var fromCodeStart, toCodeStart;

        if (fromNodeName === toNodeName) {
            return true;
        }

        fromCodeStart = fromNodeName.charCodeAt(0);
        toCodeStart = toNodeName.charCodeAt(0);

        // If the target element is a virtual DOM node or SVG node then we may
        // need to normalize the tag name before comparing. Normal HTML elements that are
        // in the "http://www.w3.org/1999/xhtml"
        // are converted to upper case
        if (fromCodeStart <= 90 && toCodeStart >= 97) { // from is upper and to is lower
            return fromNodeName === toNodeName.toUpperCase();
        } else if (toCodeStart <= 90 && fromCodeStart >= 97) { // to is upper and from is lower
            return toNodeName === fromNodeName.toUpperCase();
        } else {
            return false;
        }
    }

    /**
     * Create an element, optionally with a known namespace URI.
     *
     * @param {string} name the element name, e.g. 'div' or 'svg'
     * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of
     * its `xmlns` attribute or its inferred namespace.
     *
     * @return {Element}
     */
    function createElementNS(name, namespaceURI) {
        return !namespaceURI || namespaceURI === NS_XHTML ?
            doc.createElement(name) :
            doc.createElementNS(namespaceURI, name);
    }

    /**
     * Copies the children of one DOM element to another DOM element
     */
    function moveChildren(fromEl, toEl) {
        var curChild = fromEl.firstChild;
        while (curChild) {
            var nextChild = curChild.nextSibling;
            toEl.appendChild(curChild);
            curChild = nextChild;
        }
        return toEl;
    }

    function syncBooleanAttrProp(fromEl, toEl, name) {
        if (fromEl[name] !== toEl[name]) {
            fromEl[name] = toEl[name];
            if (fromEl[name]) {
                fromEl.setAttribute(name, '');
            } else {
                fromEl.removeAttribute(name);
            }
        }
    }

    var specialElHandlers = {
        OPTION: function(fromEl, toEl) {
            var parentNode = fromEl.parentNode;
            if (parentNode) {
                var parentName = parentNode.nodeName.toUpperCase();
                if (parentName === 'OPTGROUP') {
                    parentNode = parentNode.parentNode;
                    parentName = parentNode && parentNode.nodeName.toUpperCase();
                }
                if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {
                    if (fromEl.hasAttribute('selected') && !toEl.selected) {
                        // Workaround for MS Edge bug where the 'selected' attribute can only be
                        // removed if set to a non-empty value:
                        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/
                        fromEl.setAttribute('selected', 'selected');
                        fromEl.removeAttribute('selected');
                    }
                    // We have to reset select element's selectedIndex to -1, otherwise setting
                    // fromEl.selected using the syncBooleanAttrProp below has no effect.
                    // The correct selectedIndex will be set in the SELECT special handler below.
                    parentNode.selectedIndex = -1;
                }
            }
            syncBooleanAttrProp(fromEl, toEl, 'selected');
        },
        /**
         * The "value" attribute is special for the <input> element since it sets
         * the initial value. Changing the "value" attribute without changing the
         * "value" property will have no effect since it is only used to the set the
         * initial value.  Similar for the "checked" attribute, and "disabled".
         */
        INPUT: function(fromEl, toEl) {
            syncBooleanAttrProp(fromEl, toEl, 'checked');
            syncBooleanAttrProp(fromEl, toEl, 'disabled');

            if (fromEl.value !== toEl.value) {
                fromEl.value = toEl.value;
            }

            if (!toEl.hasAttribute('value')) {
                fromEl.removeAttribute('value');
            }
        },

        TEXTAREA: function(fromEl, toEl) {
            var newValue = toEl.value;
            if (fromEl.value !== newValue) {
                fromEl.value = newValue;
            }

            var firstChild = fromEl.firstChild;
            if (firstChild) {
                // Needed for IE. Apparently IE sets the placeholder as the
                // node value and vise versa. This ignores an empty update.
                var oldValue = firstChild.nodeValue;

                if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {
                    return;
                }

                firstChild.nodeValue = newValue;
            }
        },
        SELECT: function(fromEl, toEl) {
            if (!toEl.hasAttribute('multiple')) {
                var selectedIndex = -1;
                var i = 0;
                // We have to loop through children of fromEl, not toEl since nodes can be moved
                // from toEl to fromEl directly when morphing.
                // At the time this special handler is invoked, all children have already been morphed
                // and appended to / removed from fromEl, so using fromEl here is safe and correct.
                var curChild = fromEl.firstChild;
                var optgroup;
                var nodeName;
                while(curChild) {
                    nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();
                    if (nodeName === 'OPTGROUP') {
                        optgroup = curChild;
                        curChild = optgroup.firstChild;
                    } else {
                        if (nodeName === 'OPTION') {
                            if (curChild.hasAttribute('selected')) {
                                selectedIndex = i;
                                break;
                            }
                            i++;
                        }
                        curChild = curChild.nextSibling;
                        if (!curChild && optgroup) {
                            curChild = optgroup.nextSibling;
                            optgroup = null;
                        }
                    }
                }

                fromEl.selectedIndex = selectedIndex;
            }
        }
    };

    var ELEMENT_NODE = 1;
    var DOCUMENT_FRAGMENT_NODE$1 = 11;
    var TEXT_NODE = 3;
    var COMMENT_NODE = 8;

    function noop() {}

    function defaultGetNodeKey(node) {
      if (node) {
          return (node.getAttribute && node.getAttribute('id')) || node.id;
      }
    }

    function morphdomFactory(morphAttrs) {

        return function morphdom(fromNode, toNode, options) {
            if (!options) {
                options = {};
            }

            if (typeof toNode === 'string') {
                if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML' || fromNode.nodeName === 'BODY') {
                    var toNodeHtml = toNode;
                    toNode = doc.createElement('html');
                    toNode.innerHTML = toNodeHtml;
                } else {
                    toNode = toElement(toNode);
                }
            }

            var getNodeKey = options.getNodeKey || defaultGetNodeKey;
            var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;
            var onNodeAdded = options.onNodeAdded || noop;
            var onBeforeElUpdated = options.onBeforeElUpdated || noop;
            var onElUpdated = options.onElUpdated || noop;
            var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;
            var onNodeDiscarded = options.onNodeDiscarded || noop;
            var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;
            var childrenOnly = options.childrenOnly === true;

            // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.
            var fromNodesLookup = Object.create(null);
            var keyedRemovalList = [];

            function addKeyedRemoval(key) {
                keyedRemovalList.push(key);
            }

            function walkDiscardedChildNodes(node, skipKeyedNodes) {
                if (node.nodeType === ELEMENT_NODE) {
                    var curChild = node.firstChild;
                    while (curChild) {

                        var key = undefined;

                        if (skipKeyedNodes && (key = getNodeKey(curChild))) {
                            // If we are skipping keyed nodes then we add the key
                            // to a list so that it can be handled at the very end.
                            addKeyedRemoval(key);
                        } else {
                            // Only report the node as discarded if it is not keyed. We do this because
                            // at the end we loop through all keyed elements that were unmatched
                            // and then discard them in one final pass.
                            onNodeDiscarded(curChild);
                            if (curChild.firstChild) {
                                walkDiscardedChildNodes(curChild, skipKeyedNodes);
                            }
                        }

                        curChild = curChild.nextSibling;
                    }
                }
            }

            /**
             * Removes a DOM node out of the original DOM
             *
             * @param  {Node} node The node to remove
             * @param  {Node} parentNode The nodes parent
             * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.
             * @return {undefined}
             */
            function removeNode(node, parentNode, skipKeyedNodes) {
                if (onBeforeNodeDiscarded(node) === false) {
                    return;
                }

                if (parentNode) {
                    parentNode.removeChild(node);
                }

                onNodeDiscarded(node);
                walkDiscardedChildNodes(node, skipKeyedNodes);
            }

            // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future
            // function indexTree(root) {
            //     var treeWalker = document.createTreeWalker(
            //         root,
            //         NodeFilter.SHOW_ELEMENT);
            //
            //     var el;
            //     while((el = treeWalker.nextNode())) {
            //         var key = getNodeKey(el);
            //         if (key) {
            //             fromNodesLookup[key] = el;
            //         }
            //     }
            // }

            // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future
            //
            // function indexTree(node) {
            //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);
            //     var el;
            //     while((el = nodeIterator.nextNode())) {
            //         var key = getNodeKey(el);
            //         if (key) {
            //             fromNodesLookup[key] = el;
            //         }
            //     }
            // }

            function indexTree(node) {
                if (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE$1) {
                    var curChild = node.firstChild;
                    while (curChild) {
                        var key = getNodeKey(curChild);
                        if (key) {
                            fromNodesLookup[key] = curChild;
                        }

                        // Walk recursively
                        indexTree(curChild);

                        curChild = curChild.nextSibling;
                    }
                }
            }

            indexTree(fromNode);

            function handleNodeAdded(el) {
                onNodeAdded(el);

                var curChild = el.firstChild;
                while (curChild) {
                    var nextSibling = curChild.nextSibling;

                    var key = getNodeKey(curChild);
                    if (key) {
                        var unmatchedFromEl = fromNodesLookup[key];
                        // if we find a duplicate #id node in cache, replace `el` with cache value
                        // and morph it to the child node.
                        if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {
                            curChild.parentNode.replaceChild(unmatchedFromEl, curChild);
                            morphEl(unmatchedFromEl, curChild);
                        } else {
                          handleNodeAdded(curChild);
                        }
                    } else {
                      // recursively call for curChild and it's children to see if we find something in
                      // fromNodesLookup
                      handleNodeAdded(curChild);
                    }

                    curChild = nextSibling;
                }
            }

            function cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey) {
                // We have processed all of the "to nodes". If curFromNodeChild is
                // non-null then we still have some from nodes left over that need
                // to be removed
                while (curFromNodeChild) {
                    var fromNextSibling = curFromNodeChild.nextSibling;
                    if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {
                        // Since the node is keyed it might be matched up later so we defer
                        // the actual removal to later
                        addKeyedRemoval(curFromNodeKey);
                    } else {
                        // NOTE: we skip nested keyed nodes from being removed since there is
                        //       still a chance they will be matched up later
                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                    }
                    curFromNodeChild = fromNextSibling;
                }
            }

            function morphEl(fromEl, toEl, childrenOnly) {
                var toElKey = getNodeKey(toEl);

                if (toElKey) {
                    // If an element with an ID is being morphed then it will be in the final
                    // DOM so clear it out of the saved elements collection
                    delete fromNodesLookup[toElKey];
                }

                if (!childrenOnly) {
                    // optional
                    if (onBeforeElUpdated(fromEl, toEl) === false) {
                        return;
                    }

                    // update attributes on original DOM element first
                    morphAttrs(fromEl, toEl);
                    // optional
                    onElUpdated(fromEl);

                    if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {
                        return;
                    }
                }

                if (fromEl.nodeName !== 'TEXTAREA') {
                  morphChildren(fromEl, toEl);
                } else {
                  specialElHandlers.TEXTAREA(fromEl, toEl);
                }
            }

            function morphChildren(fromEl, toEl) {
                var curToNodeChild = toEl.firstChild;
                var curFromNodeChild = fromEl.firstChild;
                var curToNodeKey;
                var curFromNodeKey;

                var fromNextSibling;
                var toNextSibling;
                var matchingFromEl;

                // walk the children
                outer: while (curToNodeChild) {
                    toNextSibling = curToNodeChild.nextSibling;
                    curToNodeKey = getNodeKey(curToNodeChild);

                    // walk the fromNode children all the way through
                    while (curFromNodeChild) {
                        fromNextSibling = curFromNodeChild.nextSibling;

                        if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {
                            curToNodeChild = toNextSibling;
                            curFromNodeChild = fromNextSibling;
                            continue outer;
                        }

                        curFromNodeKey = getNodeKey(curFromNodeChild);

                        var curFromNodeType = curFromNodeChild.nodeType;

                        // this means if the curFromNodeChild doesnt have a match with the curToNodeChild
                        var isCompatible = undefined;

                        if (curFromNodeType === curToNodeChild.nodeType) {
                            if (curFromNodeType === ELEMENT_NODE) {
                                // Both nodes being compared are Element nodes

                                if (curToNodeKey) {
                                    // The target node has a key so we want to match it up with the correct element
                                    // in the original DOM tree
                                    if (curToNodeKey !== curFromNodeKey) {
                                        // The current element in the original DOM tree does not have a matching key so
                                        // let's check our lookup to see if there is a matching element in the original
                                        // DOM tree
                                        if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {
                                            if (fromNextSibling === matchingFromEl) {
                                                // Special case for single element removals. To avoid removing the original
                                                // DOM node out of the tree (since that can break CSS transitions, etc.),
                                                // we will instead discard the current node and wait until the next
                                                // iteration to properly match up the keyed target element with its matching
                                                // element in the original tree
                                                isCompatible = false;
                                            } else {
                                                // We found a matching keyed element somewhere in the original DOM tree.
                                                // Let's move the original DOM node into the current position and morph
                                                // it.

                                                // NOTE: We use insertBefore instead of replaceChild because we want to go through
                                                // the `removeNode()` function for the node that is being discarded so that
                                                // all lifecycle hooks are correctly invoked
                                                fromEl.insertBefore(matchingFromEl, curFromNodeChild);

                                                // fromNextSibling = curFromNodeChild.nextSibling;

                                                if (curFromNodeKey) {
                                                    // Since the node is keyed it might be matched up later so we defer
                                                    // the actual removal to later
                                                    addKeyedRemoval(curFromNodeKey);
                                                } else {
                                                    // NOTE: we skip nested keyed nodes from being removed since there is
                                                    //       still a chance they will be matched up later
                                                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                                                }

                                                curFromNodeChild = matchingFromEl;
                                            }
                                        } else {
                                            // The nodes are not compatible since the "to" node has a key and there
                                            // is no matching keyed node in the source tree
                                            isCompatible = false;
                                        }
                                    }
                                } else if (curFromNodeKey) {
                                    // The original has a key
                                    isCompatible = false;
                                }

                                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);
                                if (isCompatible) {
                                    // We found compatible DOM elements so transform
                                    // the current "from" node to match the current
                                    // target DOM node.
                                    // MORPH
                                    morphEl(curFromNodeChild, curToNodeChild);
                                }

                            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {
                                // Both nodes being compared are Text or Comment nodes
                                isCompatible = true;
                                // Simply update nodeValue on the original node to
                                // change the text value
                                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {
                                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;
                                }

                            }
                        }

                        if (isCompatible) {
                            // Advance both the "to" child and the "from" child since we found a match
                            // Nothing else to do as we already recursively called morphChildren above
                            curToNodeChild = toNextSibling;
                            curFromNodeChild = fromNextSibling;
                            continue outer;
                        }

                        // No compatible match so remove the old node from the DOM and continue trying to find a
                        // match in the original DOM. However, we only do this if the from node is not keyed
                        // since it is possible that a keyed node might match up with a node somewhere else in the
                        // target tree and we don't want to discard it just yet since it still might find a
                        // home in the final DOM tree. After everything is done we will remove any keyed nodes
                        // that didn't find a home
                        if (curFromNodeKey) {
                            // Since the node is keyed it might be matched up later so we defer
                            // the actual removal to later
                            addKeyedRemoval(curFromNodeKey);
                        } else {
                            // NOTE: we skip nested keyed nodes from being removed since there is
                            //       still a chance they will be matched up later
                            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);
                        }

                        curFromNodeChild = fromNextSibling;
                    } // END: while(curFromNodeChild) {}

                    // If we got this far then we did not find a candidate match for
                    // our "to node" and we exhausted all of the children "from"
                    // nodes. Therefore, we will just append the current "to" node
                    // to the end
                    if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {
                        fromEl.appendChild(matchingFromEl);
                        // MORPH
                        morphEl(matchingFromEl, curToNodeChild);
                    } else {
                        var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);
                        if (onBeforeNodeAddedResult !== false) {
                            if (onBeforeNodeAddedResult) {
                                curToNodeChild = onBeforeNodeAddedResult;
                            }

                            if (curToNodeChild.actualize) {
                                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);
                            }
                            fromEl.appendChild(curToNodeChild);
                            handleNodeAdded(curToNodeChild);
                        }
                    }

                    curToNodeChild = toNextSibling;
                    curFromNodeChild = fromNextSibling;
                }

                cleanupFromEl(fromEl, curFromNodeChild, curFromNodeKey);

                var specialElHandler = specialElHandlers[fromEl.nodeName];
                if (specialElHandler) {
                    specialElHandler(fromEl, toEl);
                }
            } // END: morphChildren(...)

            var morphedNode = fromNode;
            var morphedNodeType = morphedNode.nodeType;
            var toNodeType = toNode.nodeType;

            if (!childrenOnly) {
                // Handle the case where we are given two DOM nodes that are not
                // compatible (e.g. <div> --> <span> or <div> --> TEXT)
                if (morphedNodeType === ELEMENT_NODE) {
                    if (toNodeType === ELEMENT_NODE) {
                        if (!compareNodeNames(fromNode, toNode)) {
                            onNodeDiscarded(fromNode);
                            morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));
                        }
                    } else {
                        // Going from an element node to a text node
                        morphedNode = toNode;
                    }
                } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node
                    if (toNodeType === morphedNodeType) {
                        if (morphedNode.nodeValue !== toNode.nodeValue) {
                            morphedNode.nodeValue = toNode.nodeValue;
                        }

                        return morphedNode;
                    } else {
                        // Text node to something else
                        morphedNode = toNode;
                    }
                }
            }

            if (morphedNode === toNode) {
                // The "to node" was not compatible with the "from node" so we had to
                // toss out the "from node" and use the "to node"
                onNodeDiscarded(fromNode);
            } else {
                if (toNode.isSameNode && toNode.isSameNode(morphedNode)) {
                    return;
                }

                morphEl(morphedNode, toNode, childrenOnly);

                // We now need to loop over any keyed nodes that might need to be
                // removed. We only do the removal if we know that the keyed node
                // never found a match. When a keyed node is matched up we remove
                // it out of fromNodesLookup and we use fromNodesLookup to determine
                // if a keyed node has been matched up or not
                if (keyedRemovalList) {
                    for (var i=0, len=keyedRemovalList.length; i<len; i++) {
                        var elToRemove = fromNodesLookup[keyedRemovalList[i]];
                        if (elToRemove) {
                            removeNode(elToRemove, elToRemove.parentNode, false);
                        }
                    }
                }
            }

            if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {
                if (morphedNode.actualize) {
                    morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);
                }
                // If we had to swap out the from node with a new node because the old
                // node was not compatible with the target node then we need to
                // replace the old DOM node in the original DOM tree. This is only
                // possible if the original DOM node was part of a DOM tree which
                // we know is the case if it has a parent node.
                fromNode.parentNode.replaceChild(morphedNode, fromNode);
            }

            return morphedNode;
        };
    }

    var morphdom = morphdomFactory(morphAttrs);

    const ALLOWABLE_ACTIONS = [
        'advance',
        'replace',
        'restore'
    ];
    function NavigationAdapter() {
        const obj = {
            name: 'NavigationAdapter',
            connect: connect$1,
            disconnect: disconnect$1,
            cacheContains,
            prefetch,
            navigate
        };
        Object.defineProperties(obj, {
            adapter: { get: function () { return findAdapter(); } },
            snapshotCache: { get: function () { return findSnapshotCache(findAdapter()); } }
        });
        return obj;
    }
    function connect$1() {
        document.addEventListener('ajax:complete', beforeNavigation);
        document.addEventListener('ajax:beforeNavigation', navigateViaEvent);
    }
    function disconnect$1() {
        document.removeEventListener('ajax:complete', beforeNavigation);
        document.removeEventListener('ajax:beforeNavigation', navigateViaEvent);
    }
    function beforeNavigation(event) {
        if (event.defaultPrevented)
            return;
        dispatch.call(event.detail.element, 'ajax:beforeNavigation', { detail: { ...event.detail } });
    }
    function findAdapter() {
        if (useTurbolinks())
            return window.Turbolinks;
        if (useTurbo())
            return window.Turbo;
        return undefined;
    }
    function useTurbolinks() {
        if (window.Turbolinks == null)
            return false;
        if (window.Turbolinks.supported !== true)
            return false;
        return true;
    }
    function useTurbo() {
        if (window.Turbo == null)
            return false;
        return true;
    }
    function prefetch({ html, url }) {
        const expandedUrl = expandUrl(url);
        const snapshot = generateSnapshotFromHtml(html);
        putSnapshotInCache(expandedUrl, snapshot);
    }
    function findSnapshotCache(adapter) {
        if (adapter == null)
            return undefined;
        if (useTurbolinks())
            return adapter.controller.cache;
        if (useTurbo())
            return adapter.navigator.view.snapshotCache;
        return undefined;
    }
    function cacheContains(url) {
        var _a;
        const expandedUrl = expandUrl(url);
        const snapshotCache = findSnapshotCache(findAdapter());
        return (_a = snapshotCache === null || snapshotCache === void 0 ? void 0 : snapshotCache.has(expandedUrl)) !== null && _a !== void 0 ? _a : false;
    }
    /**
      * Currently, this only fires on successful form submissions.
      */
    function navigateViaEvent(event) {
        if (event.defaultPrevented)
            return;
        const { element, fetchResponse, fetchRequest } = event.detail;
        if (!shouldNavigate(element, fetchResponse))
            return;
        navigate(element, fetchRequest, fetchResponse);
    }
    function shouldNavigate(element, fetchResponse) {
        if (element.dataset.ujsNavigate === 'false')
            return false;
        if (fetchResponse == null)
            return false;
        // Only render / navigate responses on html responses.
        if (!fetchResponse.isHtml)
            return false;
        if (element instanceof HTMLFormElement && fetchResponse.succeeded && !fetchResponse.redirected) {
            console.error('Successful form submissions must redirect');
            return false;
        }
        return true;
    }
    /**
      * This is a manual navigation triggered by something like `method: :delete`
      */
    function navigate(element, request, response, action) {
        // If we get redirected, use Turbolinks
        // This needs to be reworked to not trigger 2 HTML responses or find a
        // way to not refetch a page.
        action = action !== null && action !== void 0 ? action : determineAction(element);
        let location = expandUrl(window.location.href);
        if (request === null || request === void 0 ? void 0 : request.isGetRequest)
            location = request.url;
        if (response.redirected)
            location = response.location;
        const currentLocation = window.location.href;
        const isSamePage = urlsAreEqual(location, currentLocation);
        let errorRenderer = 'morphdom';
        if (window.mrujs.errorRenderer === 'turbo' || element.getAttribute('data-ujs-error-renderer') === 'turbo') {
            errorRenderer = 'turbo';
        }
        if (response.failed || isSamePage) {
            // Use morphdom to dom diff the response if the response is HTML.
            morphResponse(element, response, !isSamePage, errorRenderer);
            return;
        }
        const adapter = findAdapter();
        if (adapter == null) {
            morphResponse(element, response, isSamePage, errorRenderer);
            return;
        }
        adapter.clearCache();
        // Special navigation handling for Turbo[links].
        preventDoubleVisit(response, location, action);
    }
    function putSnapshotInCache(location, snapshot) {
        if (snapshot === '')
            return;
        const snapshotCache = findSnapshotCache(findAdapter());
        snapshotCache === null || snapshotCache === void 0 ? void 0 : snapshotCache.put(expandUrl(location), snapshot);
    }
    function generateSnapshotFromHtml(html) {
        var _a, _b, _c;
        const adapter = findAdapter();
        if (adapter == null)
            return '';
        if (useTurbolinks()) {
            return (_a = adapter.Snapshot.wrap(html)) !== null && _a !== void 0 ? _a : '';
        }
        if (useTurbo() && canSnapshot()) {
            return (_c = (_b = adapter.PageSnapshot) === null || _b === void 0 ? void 0 : _b.fromHTMLString(html)) !== null && _c !== void 0 ? _c : '';
        }
        return '';
    }
    function canSnapshot() {
        const adapter = findAdapter();
        if (adapter == null)
            return false;
        if (useTurbolinks())
            return true;
        if (useTurbo()) {
            // PageSnapshot is required in Turbo to manually generate Snapshots.
            if (adapter.PageSnapshot == null) {
                console.warn('The version of Turbo you are currently using does not support ' +
                    'snapshot generation. Please consider upgrading your version of Turbo.');
                return false;
            }
            return true;
        }
        return false;
    }
    function preventDoubleVisit(response, location, action) {
        const adapter = findAdapter();
        if (adapter == null)
            return;
        // This is a fun wrapper to avoid double visits with Turbolinks
        response.html().then((html) => {
            prefetch({ html, url: location });
            action = 'restore';
            adapter.visit(location, { action });
        }).catch((error) => console.error(error));
    }
    function morphResponse(element, response, pushState = false, errorRenderer = 'morphdom') {
        // Dont pass go if its not HTML.
        if (!response.isHtml)
            return;
        response.html()
            .then((html) => {
            var _a;
            if (errorRenderer === 'turbo') {
                renderError(html);
            }
            else if (errorRenderer === 'morphdom') {
                const selectorString = element.getAttribute('data-ujs-morph-root');
                let selector = document.body;
                if (selectorString != null) {
                    if (selectorString.trim() === '') {
                        selector = element;
                    }
                    else {
                        selector = (_a = document.querySelector(selectorString)) !== null && _a !== void 0 ? _a : document.body;
                    }
                }
                morphHtml(html, selector);
            }
            if (pushState) {
                // https://developer.mozilla.org/en-US/docs/Web/API/History/pushState
                window.history.pushState({}, '', response.location);
            }
        })
            .catch((error) => {
            console.error(error);
        });
    }
    function morphHtml(html, selector = document.body) {
        const template = document.createElement('template');
        template.innerHTML = String(html).trim();
        morphdom(selector, template.content, { childrenOnly: true });
    }
    function renderError(html) {
        const adapter = findAdapter();
        adapter === null || adapter === void 0 ? void 0 : adapter.navigator.view.renderError(generateSnapshotFromHtml(html));
    }
    function determineAction(element) {
        var _a, _b;
        let action = (_b = (_a = element.dataset.turbolinksAction) !== null && _a !== void 0 ? _a : element.dataset.turboAction) !== null && _b !== void 0 ? _b : 'advance';
        if (!ALLOWABLE_ACTIONS.includes(action)) {
            action = 'advance';
        }
        return action;
    }

    function DisabledElementChecker() {
        const callbacks = [handleDisabledElement$1];
        let queries = [];
        function initialize() {
            queries = getQueries$1();
        }
        function connect() {
            addListeners(queries, callbacks);
        }
        function disconnect() {
            removeListeners(queries, callbacks);
        }
        function observerCallback(nodeList) {
            attachObserverCallback(queries, nodeList, callbacks);
        }
        return {
            name: 'DisabledElementChecker',
            initialize,
            connect,
            disconnect,
            observerCallback,
            queries,
            callbacks
        };
    }
    function getQueries$1() {
        const { linkClickSelector, buttonClickSelector, inputChangeSelector, formSubmitSelector, formInputClickSelector } = window.mrujs;
        return [
            { event: 'click', selectors: [buttonClickSelector, linkClickSelector, formInputClickSelector] },
            { event: 'change', selectors: [inputChangeSelector] },
            { event: 'submit', selectors: [formSubmitSelector] }
        ];
    }
    function handleDisabledElement$1(event) {
        if (this.disabled === true)
            stopEverything$1(event);
    }

    function ElementEnabler() {
        const callbacks = [enableElement$1];
        let queries = [];
        function initialize() {
            queries = getQueries();
        }
        function connect() {
            addListeners(queries, callbacks);
        }
        function disconnect() {
            removeListeners(queries, callbacks);
        }
        function observerCallback(nodeList) {
            attachObserverCallback(queries, nodeList, callbacks);
        }
        return {
            name: 'ElementEnabler',
            initialize,
            connect,
            disconnect,
            observerCallback,
            callbacks
        };
    }
    function getQueries() {
        const { formSubmitSelector, buttonDisableSelector, linkDisableSelector, inputChangeSelector } = window.mrujs;
        const selectors = [linkDisableSelector, buttonDisableSelector,
            formSubmitSelector, inputChangeSelector];
        return [
            { event: AJAX_EVENTS.ajaxComplete, selectors: selectors },
            { event: AJAX_EVENTS.ajaxStopped, selectors: selectors },
            { event: 'turbo:submit-end', selectors: selectors }
        ];
    }
    // Unified function to enable an element (link, button and form)
    function enableElement$1(trigger) {
        let element = trigger;
        if (trigger instanceof Event)
            element = trigger.target;
        const { linkDisableSelector, buttonDisableSelector, formEnableSelector, formSubmitSelector } = window.mrujs;
        if (matches$1(element, linkDisableSelector)) {
            enableLinkElement(element);
            return;
        }
        if (matches$1(element, buttonDisableSelector) || matches$1(element, formEnableSelector)) {
            enableFormElement(element);
            return;
        }
        if (matches$1(element, formSubmitSelector)) {
            enableFormElements(element);
        }
    }
    /**
      * Restore element to its original state which was disabled by 'disableLinkElement' above
      */
    function enableLinkElement(element) {
        const originalText = element.dataset.ujsEnableWith;
        if (originalText != null) {
            element.innerHTML = originalText; // set to old enabled state
            element.removeAttribute('data-ujs-enable-with'); // clean up cache
        }
        element.removeEventListener('click', stopEverything$1); // enable element
        element.removeAttribute('data-ujs-disabled');
    }
    /**
     * Re-enables disabled form elements:
     *  - Replaces element text with cached value from 'ujs-enable-with' data store (created in `disableFormElements`)
     *  - Sets disabled property to false
     */
    function enableFormElements(form) {
        const elements = formElements$1(form, window.mrujs.formEnableSelector);
        elements.forEach(enableFormElement);
    }
    function enableFormElement(element) {
        const originalText = element.dataset.ujsEnableWith;
        if (originalText != null) {
            if (matches$1(element, 'button')) {
                element.innerHTML = originalText;
            }
            else {
                element.value = originalText;
            }
            element.removeAttribute('data-ujs-enable-with'); // clean up cache
        }
        element.disabled = false;
        element.removeAttribute('data-ujs-disabled');
    }

    /**
     * Mutation observer for added nodes.
     */
    function AddedNodesObserver(callback) {
        const observer = new MutationObserver(callback);
        function connect() {
            observer.observe(document, { childList: true, subtree: true, attributes: true });
        }
        function disconnect() {
            observer.disconnect();
        }
        return {
            name: 'AddedNodesObserver',
            connect,
            disconnect
        };
    }

    function Mrujs(obj = {}) {
        var _a;
        obj.connected = false;
        obj = { ...BASE_SELECTORS };
        obj.FetchResponse = FetchResponse$1;
        obj.FetchRequest = FetchRequest$1;
        obj.addedNodesObserver = AddedNodesObserver(addedNodesCallback);
        obj.remoteWatcher = RemoteWatcher();
        obj.elementEnabler = ElementEnabler();
        obj.elementDisabler = ElementDisabler();
        obj.disabledElementChecker = DisabledElementChecker();
        obj.navigationAdapter = NavigationAdapter();
        obj.clickHandler = ClickHandler();
        obj.confirmClass = Confirm();
        obj.csrf = Csrf();
        obj.method = Method();
        obj.formSubmitDispatcher = FormSubmitDispatcher();
        // Order matters here!
        const corePlugins = [
            obj.addedNodesObserver,
            obj.remoteWatcher,
            obj.csrf,
            obj.elementEnabler,
            obj.clickHandler,
            obj.disabledElementChecker,
            obj.confirmClass,
            obj.elementDisabler,
            obj.method,
            obj.formSubmitDispatcher,
            obj.navigationAdapter
        ];
        obj.corePlugins = corePlugins;
        const plugins = (_a = obj.plugins) !== null && _a !== void 0 ? _a : [];
        obj.plugins = plugins;
        const allPlugins = corePlugins.concat(plugins);
        obj.allPlugins = allPlugins;
        obj.maskLinkMethods = true;
        obj.mimeTypes = { ...BASE_ACCEPT_HEADERS };
        obj.stop = stop;
        obj.restart = restart;
        obj.fetch = fetch;
        obj.urlEncodeFormData = urlEncodeFormData;
        obj.registerMimeTypes = registerMimeTypes;
        obj.enableElement = enableElement$1;
        obj.enableFormElements = enableFormElements;
        obj.enableFormElement = enableFormElement;
        obj.disableElement = disableElement$1;
        obj.stopEverything = stopEverything$1;
        obj.dispatch = dispatch;
        obj.addListeners = addListeners;
        obj.removeListeners = removeListeners;
        obj.attachObserverCallback = attachObserverCallback;
        obj.expandUrl = expandUrl;
        obj.findSubmitter = findSubmitter;
        // a wrapper for document.querySelectorAll
        obj.$ = $$1;
        obj.CSRFProtection = CSRFProtection$1;
        obj.csrfParam = csrfParam$1;
        obj.csrfToken = csrfToken$1;
        obj.cspNonce = cspNonce$1;
        obj.confirm = confirm$1;
        obj.handleConfirm = handleConfirm$1;
        obj.handleDisabledElement = handleDisabledElement$1;
        obj.handleMethod = handleMethod$1;
        obj.start = start$1;
        obj.preventInsignificantClick = preventInsignificantClick$1;
        obj.refreshCSRFTokens = refreshCSRFTokens$1;
        obj.delegate = delegate$1;
        obj.fire = fire$1;
        obj.formElements = formElements$1;
        obj.matches = matches$1;
        obj.toArray = toArray;
        return obj;
    }
    function start$1(options = {}) {
        var _a;
        window.Rails = window.mrujs = this;
        // Dont start twice!
        if (window.mrujs.connected) {
            return window.mrujs;
        }
        Object.assign(this, options);
        this.allPlugins = this.corePlugins.concat(this.plugins);
        for (let i = 0; i < this.allPlugins.length; i++) {
            const plugin = this.allPlugins[i];
            (_a = plugin.initialize) === null || _a === void 0 ? void 0 : _a.call(plugin);
        }
        connect();
        return this;
    }
    function stop() {
        disconnect();
    }
    function restart() {
        disconnect();
        connect();
    }
    function connect() {
        var _a;
        // This event works the same as the load event, except that it fires every
        // time the page is loaded.
        // See https://github.com/rails/jquery-ujs/issues/357
        // See https://developer.mozilla.org/en-US/docs/Using_Firefox_1.5_caching
        reEnableDisabledElements();
        window.addEventListener('pageshow', reEnableDisabledElements);
        for (let i = 0; i < window.mrujs.allPlugins.length; i++) {
            const plugin = window.mrujs.allPlugins[i];
            (_a = plugin.connect) === null || _a === void 0 ? void 0 : _a.call(plugin);
        }
        window.mrujs.connected = true;
    }
    function disconnect() {
        var _a;
        window.removeEventListener('pageshow', reEnableDisabledElements);
        for (let i = 0; i < window.mrujs.allPlugins.length; i++) {
            const plugin = window.mrujs.allPlugins[i];
            (_a = plugin.disconnect) === null || _a === void 0 ? void 0 : _a.call(plugin);
        }
        window.mrujs.connected = false;
    }
    function confirm$1(message) {
        return window.confirm(message);
    }
    function addedNodesCallback(mutationList, _observer) {
        for (const mutation of mutationList) {
            let addedNodes;
            if (mutation.type === 'attributes') {
                addedNodes = [mutation.target];
            }
            else {
                addedNodes = Array.from(mutation.addedNodes);
            }
            // kick it into setTimeout so we dont delay rendering
            window.setTimeout(() => {
                var _a;
                for (let i = 0; i < window.mrujs.allPlugins.length; i++) {
                    const plugin = window.mrujs.allPlugins[i];
                    (_a = plugin.observerCallback) === null || _a === void 0 ? void 0 : _a.call(plugin, addedNodes);
                }
            }, 0);
        }
    }
    function fetch(input, options = {}) {
        let { element, submitter, dispatchEvents } = options;
        delete options.element;
        delete options.submitter;
        delete options.dispatchEvents;
        const fetchRequest = FetchRequest$1(input, options);
        if (dispatchEvents === true) {
            if (element == null)
                element = document.documentElement;
            dispatch.call(element, AJAX_EVENTS.ajaxBeforeSend, {
                detail: { element, fetchRequest, request: fetchRequest.request, submitter }
            });
            return undefined;
        }
        return window.fetch(fetchRequest.request);
    }
    function registerMimeTypes(mimeTypes) {
        mimeTypes.forEach((mimeType) => {
            const { shortcut, header } = mimeType;
            window.mrujs.mimeTypes[shortcut] = header;
        });
        return window.mrujs.mimeTypes;
    }
    function reEnableDisabledElements() {
        const { formEnableSelector, linkDisableSelector } = window.mrujs;
        $$1(`${formEnableSelector}, ${linkDisableSelector}`)
            .forEach(element => {
            const el = element;
            // Reenable any elements previously disabled
            enableElement$1(el);
        });
    }
    function cspNonce$1() {
        return getMetaContent('csp-nonce');
    }

    // Currently only import the safari submit event polyfill.
    const mrujs = Mrujs();
    // Yay...esmodules!
    const { $, CSRFProtection, buttonClickSelector, buttonDisableSelector, cspNonce, csrfParam, csrfToken, confirm, delegate, disableElement, enableElement, fileInputSelector, fire, formDisableSelector, formElements, formEnableSelector, formInputClickSelector, formSubmitSelector, handleConfirm, handleDisabledElement, handleMethod, inputChangeSelector, linkClickSelector, linkDisableSelector, matches, preventInsignificantClick, refreshCSRFTokens, start, stopEverything, FetchResponse, FetchRequest } = mrujs;

    exports.$ = $;
    exports.CSRFProtection = CSRFProtection;
    exports.FetchRequest = FetchRequest;
    exports.FetchResponse = FetchResponse;
    exports.Mrujs = Mrujs;
    exports.buttonClickSelector = buttonClickSelector;
    exports.buttonDisableSelector = buttonDisableSelector;
    exports.confirm = confirm;
    exports.cspNonce = cspNonce;
    exports.csrfParam = csrfParam;
    exports.csrfToken = csrfToken;
    exports["default"] = mrujs;
    exports.delegate = delegate;
    exports.disableElement = disableElement;
    exports.enableElement = enableElement;
    exports.fileInputSelector = fileInputSelector;
    exports.fire = fire;
    exports.formDisableSelector = formDisableSelector;
    exports.formElements = formElements;
    exports.formEnableSelector = formEnableSelector;
    exports.formInputClickSelector = formInputClickSelector;
    exports.formSubmitSelector = formSubmitSelector;
    exports.handleConfirm = handleConfirm;
    exports.handleDisabledElement = handleDisabledElement;
    exports.handleMethod = handleMethod;
    exports.inputChangeSelector = inputChangeSelector;
    exports.linkClickSelector = linkClickSelector;
    exports.linkDisableSelector = linkDisableSelector;
    exports.matches = matches;
    exports.mrujs = mrujs;
    exports.preventInsignificantClick = preventInsignificantClick;
    exports.refreshCSRFTokens = refreshCSRFTokens;
    exports.start = start;
    exports.stopEverything = stopEverything;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=index.umd.js.map
