import morphdom from 'morphdom';

// Shamelessly stolen from Turbo. Makes the submit event listenable from Safari.
// https://github.com/hotwired/turbo/blob/main/src/polyfills/submit-event.ts
const submittersByForm = new WeakMap();
function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = (element != null) ? element.closest('input, button') : null;
    if ((candidate != null) && candidate.type === 'submit') {
        return candidate;
    }
    return null;
}
function clickCaptured(event) {
    const submitter = findSubmitterFromClickTarget(event.target);
    if ((submitter === null || submitter === void 0 ? void 0 : submitter.form) != null) {
        submittersByForm.set(submitter.form, submitter);
    }
}
(function () {
    let prototype = Event.prototype;
    // Safari 15 has a bug with submitters, this is a check for that.
    const isSafari = navigator.vendor.includes('Apple Computer');
    if ('SubmitEvent' in window) {
        // No need to continue, polyfill not needed. Safari 15 has a bug with submitters.
        if (!isSafari)
            return;
        // We have to attach to the SubmitEvent prototype in Safari instead of Event prototype.
        prototype = window.SubmitEvent.prototype;
    }
    // Polyfill has already been run, do not pass go.
    if ('submitter' in prototype)
        return;
    addEventListener('click', clickCaptured, true);
    Object.defineProperty(prototype, 'submitter', {
        get() {
            if (this.type === 'submit' && this.target instanceof HTMLFormElement) {
                return submittersByForm.get(this.target);
            }
            return undefined;
        }
    });
})();

var _a;
function toArray(value) {
    if (Array.isArray(value)) {
        return value;
    }
    else if (Array.from != null) {
        return Array.from(value);
    }
    else {
        return [].slice.call(value);
    }
}
const m = (_a = Element.prototype.matches) !== null && _a !== void 0 ? _a : Element.prototype.webkitMatchesSelector;
/**
 * Checks if the given native dom element matches the selector
 * @example
 *   matches(document.querySelector("form"), { selector: "form", exclude: "form[data-remote='true']"})
 *   matches(document.querySelector("form"), "form")
 */
function matches$1(element, selector) {
    if (!(element instanceof Element)) {
        return false;
    }
    if (typeof selector === 'string') {
        return m.call(element, selector);
    }
    return m.call(element, selector.selector) && !m.call(element, selector.exclude);
}
let form = 'form';
let link = 'a';
if (window.Turbo != null) {
    form = 'form[data-turbo="false"]';
    link = 'a[data-turbo="false"]';
}
const data = 'data-';
const remote = `${data}remote`;
const method = `${data}method`;
const confirm$2 = `${data}confirm`;
const disable = `${data}disable`;
const disableWith = `${disable}-with`;
const BASE_SELECTORS = {
    remoteSelector: `a[${remote}="true"], a[${method}], form[${remote}="true"]`,
    // Link elements bound by rails-ujs
    linkClickSelector: `a[${confirm$2}], ${link}[${method}], ${link}[${remote}]:not([disabled]), ${link}[${disableWith}], ${link}[${disable}]`,
    // Button elements bound by rails-ujs
    buttonClickSelector: {
        selector: `button[${remote}]:not([form]), button[${confirm$2}]:not([form]), button[${disableWith}]:not([form]), button[${disable}]:not([form])`,
        exclude: 'form button'
    },
    // Select elements bound by rails-ujs
    inputChangeSelector: `select[${remote}], input[${remote}], textarea[${remote}]`,
    // Form elements bound by rails-ujs
    formSubmitSelector: `${form}`,
    // Form input elements bound by rails-ujs
    formInputClickSelector: 'form input[type=submit], form input[type=image], form button[type=submit], form button:not([type]), input[type=submit][form], input[type=image][form], button[type=submit][form], button[form]:not([type])',
    // Form input elements disabled during form submission
    formDisableSelector: `input[${disableWith}]:enabled, button[${disableWith}]:enabled, textarea[${disableWith}]:enabled, input[${disable}]:enabled, button[${disable}]:enabled, textarea[${disable}]:enabled`,
    // Form input elements re-enabled after form submission
    formEnableSelector: `input[${disableWith}]:disabled, button[${disableWith}]:disabled, textarea[${disableWith}]:disabled, input[${disable}]:disabled, button[${disable}]:disabled, textarea[${disable}]:disabled`,
    // Link onClick disable selector with possible reenable after remote submission
    linkDisableSelector: `a[${disableWith}], a[${disable}]`,
    // Button onClick disable selector with possible reenable after remote submission
    buttonDisableSelector: `button[data-remote][${disableWith}], button[data-remote][${disable}]`,
    fileInputSelector: 'fileInputSelector: \'input[name][type=file]:not([disabled])\''
};
function addListeners(conditions, callbacks) {
    conditions.forEach((condition) => {
        const { selectors, event } = condition;
        const selectorString = selectors.map(selectorToString).join(', ');
        $$1(selectorString).forEach((el) => {
            selectors.forEach((selector) => {
                if (matches$1(el, selector)) {
                    callbacks.forEach((callback) => el.addEventListener(event, callback));
                }
            });
        });
    });
}
function removeListeners(conditions, callbacks) {
    conditions.forEach((condition) => {
        const { selectors, event } = condition;
        const selectorString = selectors.map(selectorToString).join(', ');
        $$1(selectorString).forEach((el) => {
            selectors.forEach((selector) => {
                if (matches$1(el, selector)) {
                    callbacks.forEach((callback) => el.removeEventListener(event, callback));
                }
            });
        });
    });
}
function attachObserverCallback(conditions, nodeList, callbacks) {
    conditions.forEach((condition) => {
        condition.selectors.forEach((selector) => {
            nodeList.forEach((node) => {
                if (matches$1(node, selector)) {
                    callbacks.forEach((cb) => node.addEventListener(condition.event, cb));
                }
                if (node instanceof Element) {
                    node.querySelectorAll(selectorToString(selector)).forEach((el) => {
                        callbacks.forEach((cb) => el.addEventListener(condition.event, cb));
                    });
                }
            });
        });
    });
}
/**
 * Helper function that returns form elements that match the specified CSS selector
 *   If form is actually a "form" element this will return associated elements outside the from that have
 *   the html form attribute set
 */
function formElements$1(form, selector) {
    if (matches$1(form, 'form')) {
        return Array.from(form.elements).filter((el) => matches$1(el, selector));
    }
    return toArray(form.querySelectorAll(selectorToString(selector)));
}
function $$1(selector) {
    return toArray((document.querySelectorAll(selector)));
}
function selectorToString(selector) {
    let str;
    if (typeof selector === 'string') {
        str = selector;
    }
    else {
        str = selector.selector;
    }
    return str;
}

const EVENT_DEFAULTS = {
    bubbles: true,
    cancelable: true
};
/**
 * Thin wrapper around element.dispatchEvent and new CustomEvent
 */
function dispatch(name, options = {}) {
    const event = new CustomEvent(name, { ...EVENT_DEFAULTS, ...options });
    this.dispatchEvent(event);
    return event;
}
/**
 * Backwards compatibility function that hooks into dispatch.
 */
function fire$1(element, name, options = {}) {
    const event = dispatch.call(element, name, options);
    return !event.defaultPrevented;
}
function stopEverything$1(event) {
    if (event.target != null)
        fire$1(event.target, 'ujs:everythingStopped');
    event.stopPropagation();
    event.stopImmediatePropagation();
    event.preventDefault();
}
const prefix = 'ajax';
const AJAX_EVENTS = {
    /**
     * Before the ajax event gets sent.
     * You can view what data will be sent via: `event.detail.formData`
     */
    ajaxBefore: `${prefix}:before`,
    /**
     * Just prior to sending the fetch request
     */
    ajaxBeforeSend: `${prefix}:beforeSend`,
    /**
     * When the fetch request is sent. You can view whats being sent via:
     * `event.detail.formData`
     */
    ajaxSend: `${prefix}:send`,
    /**
     * When a response error occurs. IE: 400, 404, 422, 500, etc (any status code not between 200 - 299)
     * The response error can be viewed via: `event.detail.response`
     */
    ajaxResponseError: `${prefix}:response:error`,
    /**
     * Catches errors with requests such as Network errors.
     */
    ajaxRequestError: `${prefix}:request:error`,
    /**
     * When a >= 200 and <= 299 response is returned
     * You can view the full response via: `event.detail.response`
     */
    ajaxSuccess: `${prefix}:success`,
    /**
     * A unified event to catch both Response and Request errors.
     * You can view the error via: `event.detail.error`
     * This will also generate an error in your console.log
     */
    ajaxError: `${prefix}:error`,
    /**
     * After any fetch request, regardless of outcome
     * Does not have any accessible data besides the event itself
     */
    ajaxComplete: `${prefix}:complete`,
    ajaxStopped: `${prefix}:stopped`,
    ajaxBeforeNavigation: `${prefix}:beforeNavigation`
    // NOT CURRENTLY IMPLEMENTED
    // /**
    //  * when there are blank required fields in a form, submits anyway if stopped
    //  */
    // ajaxAbortedRequired: `${prefix}:aborted:required`,
    // /**
    //  * if there are non-blank input:file fields in a form, aborts if stopped
    //  */
    // ajaxAbortedFile: `${prefix}:aborted:file`
};
/**
 * Delegates events
 * to a specified parent `element`, which fires event `handler`
 * for the specified `selector` when an event of `eventType` is triggered
 * element::
 *   parent element that will listen for events e.g. document
 * selector::
 *   css selector; or an object that has `selector` and `exclude` properties (see: Rails.matches)
 * eventType::
 *   string representing the event e.g. 'submit', 'click'
 * handler::
 *   the event handler to be called
 */
function delegate$1(element, selector, eventType, handler) {
    element.addEventListener(eventType, (event) => {
        let target = event.target;
        while (!(!(target instanceof Element) || matches$1(target, selector))) {
            target = target.parentNode;
        }
        if (target instanceof Element && handler.call(target, event) === false) {
            event.preventDefault();
            event.stopPropagation();
        }
    });
}

function findSubmitter(event) {
    var _a;
    // Not supported by webkit
    if (event.submitter instanceof HTMLElement) {
        return event.submitter;
    }
    // we have a polyfill that adds submitter on event.detail
    return (_a = event.detail) === null || _a === void 0 ? void 0 : _a.submitter;
}

function expandUrl(locateable) {
    return new URL(locateable.toString(), document.baseURI);
}
function urlsAreEqual(left, right) {
    return expandUrl(left).href === expandUrl(right).href;
}
function mergeHeaders(...sources) {
    const main = {};
    for (const source of sources) {
        for (const [header, value] of source) {
            main[header] = value;
        }
    }
    return new Headers(main);
}
function isGetRequest(method) {
    return method.toLowerCase() === 'get';
}

// Shamelessly stolen from Turbo.
// https://github.com/hotwired/turbo/blob/main/src/http/fetch_response.ts
function FetchResponse$1(response) {
    let _text;
    let _json;
    const succeeded = response.ok;
    const status = response.status;
    const failed = !succeeded;
    const clientError = (response.status >= 400 && response.status <= 499);
    const serverError = (response.status >= 500 && response.status <= 599);
    const redirected = response.redirected;
    const location = expandUrl(response.url);
    const contentType = getHeader('content-type');
    const isHtml = Boolean(contentType === null || contentType === void 0 ? void 0 : contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/));
    const isJson = Boolean(contentType === null || contentType === void 0 ? void 0 : contentType.toLowerCase().match(/(^application\/json|\.json)/));
    async function text() {
        if (_text != null)
            return _text;
        _text = await response.clone().text();
        return _text;
    }
    async function html() {
        if (isHtml)
            return await text();
        return await Promise.reject(response);
    }
    async function json() {
        if (isJson) {
            if (_json != null)
                return _json;
            _json = JSON.parse(await text());
            return _json;
        }
        return await Promise.reject(response);
    }
    function getHeader(name) {
        return response.headers.get(name);
    }
    return {
        succeeded,
        failed,
        redirected,
        clientError,
        serverError,
        location,
        contentType,
        getHeader,
        isHtml,
        isJson,
        text,
        html,
        json,
        response,
        status
    };
}

function buildFormElementFormData(element, submitter) {
    const formData = new FormData(element);
    let name;
    let value;
    if (submitter != null) {
        name = submitter.getAttribute('name');
        value = submitter.getAttribute('value');
    }
    if (name != null && value != null && formData.get(name) !== value) {
        formData.append(name, value);
    }
    return formData;
}
const FormEncTypes = {
    urlEncoded: 'application/x-www-form-urlencoded',
    multipart: 'multipart/form-data',
    plain: 'text/plain'
};
function formEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
        case FormEncTypes.multipart: return FormEncTypes.multipart;
        case FormEncTypes.plain: return FormEncTypes.plain;
        default: return FormEncTypes.urlEncoded;
    }
}
function formDataToStrings(formData) {
    return [...formData].reduce((entries, [name, value]) => {
        return entries.concat(typeof value === 'string' ? [[name, value]] : []);
    }, []);
}
function urlEncodeFormData(formData) {
    return new URLSearchParams(formDataToStrings(formData));
}

const BASE_ACCEPT_HEADERS = {
    '*': '*/*',
    any: '*/*',
    text: 'text/plain',
    html: 'text/html',
    xml: 'application/xml, text/xml',
    json: 'application/json, text/javascript',
    script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript'
};
function findResponseTypeHeader(responseType) {
    var _a, _b, _c;
    const mimeTypes = (_b = (_a = window.mrujs) === null || _a === void 0 ? void 0 : _a.mimeTypes) !== null && _b !== void 0 ? _b : BASE_ACCEPT_HEADERS;
    const acceptHeaders = {
        ...mimeTypes
    };
    if (responseType == null) {
        return (_c = acceptHeaders === null || acceptHeaders === void 0 ? void 0 : acceptHeaders.any) !== null && _c !== void 0 ? _c : '*/*';
    }
    responseType = responseType.trim();
    if ((acceptHeaders != null) && Object.keys(acceptHeaders).includes(responseType)) {
        responseType = acceptHeaders[responseType];
    }
    if (responseType.includes('*/*'))
        return responseType;
    return `${responseType}, */*; q=0.01`;
}

function isInsignificantClick(event) {
    return (((event.target != null) && event.target.isContentEditable) ||
        event.defaultPrevented ||
        event.button > 0 || // Only left clicks!
        event.altKey ||
        event.ctrlKey ||
        event.metaKey ||
        event.shiftKey);
}
function isSignificantClick(event) {
    return !isInsignificantClick(event);
}
function preventInsignificantClick$1(event) {
    if (isSignificantClick(event))
        return;
    stopEverything$1(event);
}
function getCookieValue(cookieName) {
    if (cookieName != null) {
        const cookies = document.cookie.trim() !== '' ? document.cookie.split('; ') : [];
        const cookie = cookies.find((cookie) => cookie.startsWith(cookieName));
        if (cookie != null) {
            const value = cookie.split('=').slice(1).join('=');
            return (value.trim() !== '' ? decodeURIComponent(value) : undefined);
        }
    }
    return undefined;
}
function getMetaContent(str) {
    var _a;
    const elements = $$1(`meta[name="${str}"]`);
    const element = elements[elements.length - 1];
    return (_a = element === null || element === void 0 ? void 0 : element.content) !== null && _a !== void 0 ? _a : undefined;
}

// https://github.com/rails/rails/blob/main/actionview/app/assets/javascripts/rails-ujs/utils/csrf.coffee
function Csrf() {
    return {
        name: 'Csrf',
        connect: connect$3,
        disconnect: disconnect$3,
        observerCallback
    };
}
function connect$3() {
    refreshCSRFTokens$1();
}
function disconnect$3() { }
function observerCallback(nodeList) {
    for (let i = 0; i < nodeList.length; i++) {
        const node = nodeList[i];
        if (isCsrfToken(node)) {
            refreshCSRFTokens$1();
        }
    }
}
// Make sure that all forms have actual up-to-date tokens (cached forms contain old ones)
function refreshCSRFTokens$1() {
    const token = csrfToken$1();
    const param = csrfParam$1();
    if (token != null && param != null) {
        $$1(`form input[name="${param}"]`).forEach(input => {
            const inputEl = input;
            inputEl.value = token;
        });
    }
}
function isCsrfToken(node) {
    if (node instanceof HTMLMetaElement) {
        return node.matches('meta[name="csrf-token]"');
    }
    return false;
}
// Up-to-date Cross-Site Request Forgery token
function csrfToken$1() {
    var _a;
    return (_a = getCookieValue(csrfParam$1())) !== null && _a !== void 0 ? _a : getMetaContent('csrf-token');
}
// URL param that must contain the CSRF token
function csrfParam$1() {
    return getMetaContent('csrf-param');
}
function CSRFProtection$1(request) {
    const token = csrfToken$1();
    const str = 'X-CSRF-TOKEN';
    if (token != null && request.headers.get(str) == null)
        request.headers.set('X-CSRF-TOKEN', token);
}

/**
 * Fetch Request is essentially an "proxy" class meant to wrap a standard Request
 *   Object and provide some sane convetions like passing in an abort controller,
 *   auto-serialization of FormData, auto-filling X-CSRF-Token and a number of other
 *   niceties. The FetchRequest constructor follows the same conventions as fetch.
 *   It can either take in a Request object, or be giving a url and then an object
 *   with all the fetch options.
 */
function FetchRequest$1(input, options = {}) {
    const abortController = new AbortController();
    const abortSignal = abortController.signal;
    let headers;
    let url;
    let method = 'get';
    let request;
    let _isGetRequest = false;
    method = getMethod$1(options);
    _isGetRequest = isGetRequest(method);
    const body = getBody$2(options);
    if (input instanceof Request) {
        url = getUrl(input.url, _isGetRequest, body);
        request = createRequestFromRequest(input);
    }
    else {
        url = getUrl(input, _isGetRequest, body);
        request = createRequestFromLocateable();
    }
    if (!_isGetRequest)
        CSRFProtection$1(request);
    headers = request.headers;
    const params = url.searchParams;
    return {
        request,
        method,
        url,
        body,
        params,
        abortController,
        abortSignal,
        cancel,
        headers,
        isGetRequest: _isGetRequest
    };
    function defaultHeaders() {
        const headers = new Headers({
            Accept: '*/*',
            'X-REQUESTED-WITH': 'XmlHttpRequest'
        });
        return headers;
    }
    function cancel(event) {
        abortController.abort();
        // trigger event dispatching if an event gets passed in.
        if (event != null) {
            stopEverything$1(event);
            const { element } = event.detail;
            dispatch.call(element, AJAX_EVENTS.ajaxStopped, {
                detail: { ...event.detail }
            });
        }
    }
    function createRequestFromRequest(input) {
        headers = mergeHeaders(defaultHeaders(), input.headers);
        const mergedOptions = { ...defaultRequestOptions(), ...input };
        // @ts-expect-error
        if (_isGetRequest)
            delete mergedOptions.body;
        // @ts-expect-error this.url is really a URL, but typescript seems to think Request cant handle it.
        return new Request(url, mergedOptions);
    }
    function createRequestFromLocateable() {
        headers = mergeHeaders(defaultHeaders(), new Headers(options.headers));
        const mergedOptions = { ...defaultRequestOptions(), ...options };
        mergedOptions.headers = headers;
        if (_isGetRequest)
            delete mergedOptions.body;
        // @ts-expect-error this.url is really a URL, but typescript seems to think Request cant handle it.
        return new Request(url, mergedOptions);
    }
    function defaultRequestOptions() {
        const options = {
            method,
            headers,
            credentials: 'same-origin',
            redirect: 'follow',
            signal: abortSignal
        };
        if (_isGetRequest) {
            return options;
        }
        options.body = body;
        return options;
    }
}
function getUrl(url, getRequest, body) {
    const location = expandUrl(url);
    if (!getRequest)
        return location;
    // Append params to the Url.
    return mergeFormDataEntries(location, entries(body));
}
function entries(body) {
    return body instanceof URLSearchParams ? Array.from(body.entries()) : [];
}
function getBody$2(input) {
    var _a;
    return ((_a = input.body) !== null && _a !== void 0 ? _a : new URLSearchParams());
}
function getMethod$1(input) {
    var _a, _b;
    return ((_b = (_a = input.method) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== null && _b !== void 0 ? _b : 'get');
}
function mergeFormDataEntries(url, entries) {
    const currentSearchParams = new URLSearchParams(url.search);
    for (const [name, value] of entries) {
        if (value instanceof File)
            continue;
        // Only happens on GET requests, not needed.
        if (name === 'authenticity_token')
            continue;
        if (currentSearchParams.has(name)) {
            currentSearchParams.delete(name);
            url.searchParams.set(name, value);
        }
        else {
            url.searchParams.append(name, value);
        }
    }
    return url;
}

/**
 * This handles FormSubmissions on forms that use data-remote="true"
 * This should not be interacted with directly and instead is merely meant for
 * connecting to the DOM.
 */
function FormSubmission(element, submitter) {
    const url = expandUrl(getAction(element, submitter));
    const options = getOptions(element, submitter);
    const fetchRequest = FetchRequest$1(url, options);
    const request = fetchRequest.request;
    return {
        fetchRequest,
        request,
        element,
        submitter
    };
}
function getOptions(element, submitter) {
    const method = getMethod(element, submitter);
    const headers = getHeaders$1(element);
    const options = {
        method,
        headers
    };
    // Will get stripped out by FetchRequest if its a GET request.
    options.body = getBody$1(element, method, submitter);
    return options;
}
/**
  * Headers to send to the request object
  */
function getHeaders$1(element) {
    let responseType;
    if (element != null) {
        responseType = element.dataset.type;
    }
    const acceptHeader = findResponseTypeHeader(responseType);
    const headers = new Headers({ Accept: acceptHeader });
    headers.set('Accept', acceptHeader);
    return headers;
}
/**
  * Returns properly built FormData
  */
function getFormData$1(element, submitter) {
    return buildFormElementFormData(element, submitter);
}
/**
  * Finds how to send the fetch request
  * get, post, put, patch, etc
  */
function getMethod(element, submitter) {
    var _a, _b;
    const method = (_b = (_a = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute('formmethod')) !== null && _a !== void 0 ? _a : element.getAttribute('method')) !== null && _b !== void 0 ? _b : 'get';
    return method.toLowerCase();
}
function getAction(element, submitter) {
    var _a, _b;
    const action = (_b = (_a = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute('formaction')) !== null && _a !== void 0 ? _a : element.getAttribute('action')) !== null && _b !== void 0 ? _b : '';
    return action;
}
function getBody$1(element, method, submitter) {
    const formData = getFormData$1(element, submitter);
    if (getEncType(element, submitter) === FormEncTypes.urlEncoded || (isGetRequest(method))) {
        return urlEncodeFormData(formData);
    }
    else {
        return formData;
    }
}
function getEncType(element, submitter) {
    var _a, _b;
    const elementEncType = element.getAttribute('enctype');
    const encType = (_b = (_a = submitter === null || submitter === void 0 ? void 0 : submitter.getAttribute('formenctype')) !== null && _a !== void 0 ? _a : elementEncType) !== null && _b !== void 0 ? _b : FormEncTypes.urlEncoded;
    const encString = formEnctypeFromString(encType);
    return encString;
}

function ElementDisabler() {
    const callbacks = [disableElement$1];
    let queries = [];
    function initialize() {
        queries = getQueries$5();
    }
    function connect() {
        addListeners(queries, callbacks);
    }
    function disconnect() {
        removeListeners(queries, callbacks);
    }
    function observerCallback(nodeList) {
        attachObserverCallback(queries, nodeList, callbacks);
    }
    return {
        name: 'ElementDisabler',
        initialize,
        connect,
        disconnect,
        observerCallback,
        queries
    };
}
function getQueries$5() {
    const { formSubmitSelector, linkClickSelector, buttonClickSelector, inputChangeSelector } = window.mrujs;
    return [
        { event: 'click', selectors: [buttonClickSelector, linkClickSelector] },
        { event: 'ajax:send', selectors: [formSubmitSelector] },
        { event: 'turbo:submit-start', selectors: ['form'] },
        { event: 'change', selectors: [inputChangeSelector] }
    ];
}
/**
  * Unified function to disable an element (link, button and form)
  */
function disableElement$1(event) {
    let element;
    if (event instanceof Event) {
        element = event.target;
    }
    else {
        element = event;
    }
    if (element == null)
        return;
    const { linkDisableSelector, buttonDisableSelector, formDisableSelector, formSubmitSelector } = window.mrujs;
    if (matches$1(element, linkDisableSelector)) {
        disableLinkElement(element);
    }
    else if (matches$1(element, buttonDisableSelector) || matches$1(element, formDisableSelector)) {
        disableFormElement(element);
    }
    else if (matches$1(element, formSubmitSelector)) {
        disableFormElements(element);
    }
}
/**
  * Disables form elements:
  *   - Caches element value in 'ujs-enable-with' data store
  *   - Replaces element text with value of 'data-disable-with' attribute
  *   - Sets disabled property to true
  */
function disableFormElements(form) {
    formElements$1(form, window.mrujs.formDisableSelector).forEach((el) => disableFormElement(el));
}
function disableFormElement(element) {
    if (element.dataset.ujsDisabled != null)
        return;
    const replacement = element.getAttribute('data-disable-with');
    if (replacement != null) {
        if (matches$1(element, 'button')) {
            element.dataset.ujsEnableWith = element.innerHTML;
            element.innerHTML = replacement;
        }
        else {
            element.dataset.ujsEnableWith = element.value;
            element.value = replacement;
        }
    }
    element.dataset.ujsDisabled = 'true';
    // Due to how FormSubmissions work in Chrome, if the button is disabled prior
    // to submitting the form, then form "submit" event will never trigger.
    setTimeout(() => { element.disabled = true; });
}
/**
  * Replace element's html with the 'data-disable-with' after storing original html
  *   and prevent clicking on it
  */
function disableLinkElement(element) {
    if (element.dataset.ujsDisabled != null)
        return;
    const replacement = element.dataset.disableWith;
    // Perhaps morph here instead??
    if (replacement != null) {
        element.dataset.ujsEnableWith = element.innerHTML;
        element.innerHTML = replacement;
    }
    element.addEventListener('click', stopEverything$1); // prevent further clicking
    element.dataset.ujsDisabled = 'true';
}

function FormSubmitDispatcher() {
    return {
        name: 'FormSubmitDispatcher',
        connect: connect$2,
        disconnect: disconnect$2
    };
}
function connect$2() {
    attachListeners('addEventListener');
}
function disconnect$2() {
    attachListeners('removeEventListener');
}
/**
  * Basic fetch request which leverages the FetchRequest object.
  *   This is an internal fetch
  *   Appropriate headers will be set for you but can be overriden.
  * @fires `ajax:before`
  */
function startFormSubmission(event) {
    if (event.defaultPrevented) {
        return;
    }
    // If it doesnt have remote="true"...forget about it!
    const element = findTarget(event);
    const submitter = findSubmitter(event);
    if (element.dataset.remote !== 'true')
        return;
    if (shouldNotSubmit(element))
        return;
    if (shouldNotSubmit(submitter))
        return;
    if (submitter != null) {
        disableElement$1(submitter);
    }
    event.preventDefault();
    const { fetchRequest, request } = FormSubmission(element, submitter);
    const detail = { element, fetchRequest, request, submitter };
    dispatch.call(element, AJAX_EVENTS.ajaxBefore, { detail });
}
/**
  * Fires off a fetch request and returns the response data. Triggered by events.
  * @fires `ajax:beforeSend`
  * The request can be found via `event.detail.request`
  */
function startFetchRequest(event) {
    const { element, fetchRequest, request, submitter } = event.detail;
    if (event.defaultPrevented || shouldNotSubmit(element) || shouldNotSubmit(submitter)) {
        dispatchStopped(event);
        return;
    }
    dispatch.call(element, AJAX_EVENTS.ajaxBeforeSend, {
        detail: { element, fetchRequest, request, submitter }
    });
}
function sendFetchRequest(event) {
    const { element, request, submitter } = event.detail;
    if (event.defaultPrevented || shouldNotSubmit(element) || shouldNotSubmit(submitter)) {
        dispatchStopped(event);
        return;
    }
    dispatch.call(element, AJAX_EVENTS.ajaxSend, { detail: { ...event.detail } });
    window.fetch(request).then((resp) => {
        const fetchResponse = FetchResponse$1(resp);
        const { response } = fetchResponse;
        dispatchResponse({ ...event.detail, fetchResponse, response });
    }).catch((error) => dispatchRequestError({ ...event.detail, error }));
}
/**
  * Handles FetchResponses
  *   Fires `ajax:response:error` or `ajax:success` depending on the response.
  *   You can find the response in `event.detail.response`

/*
  * Dispatches the `ajax:complete` event.
  * { response, request?, error?, submitter } = detail
  */
function dispatchComplete(event) {
    if (event.defaultPrevented) {
        dispatchStopped(event);
        return;
    }
    dispatch.call(findTarget(event), AJAX_EVENTS.ajaxComplete, {
        detail: { ...event.detail }
    });
}
/**
  * Handles FetchResponses
  * @fires `ajax:response:error` or `ajax:success` depending on if the response succeeded.
  * properties: { request, response, submitter } = event.detail
  */
function dispatchResponse({ element, fetchRequest, request, fetchResponse, response, submitter }) {
    const status = response === null || response === void 0 ? void 0 : response.status;
    if ((fetchResponse === null || fetchResponse === void 0 ? void 0 : fetchResponse.succeeded) === true) {
        dispatch.call(element, AJAX_EVENTS.ajaxSuccess, {
            detail: { element, fetchRequest, request, fetchResponse, response, submitter, status }
        });
        return;
    }
    // Response errors, >= 400 responses
    dispatch.call(element, AJAX_EVENTS.ajaxResponseError, {
        detail: { element, fetchRequest, request, fetchResponse, response, submitter, status }
    });
}
/**
  * Handles a `fetch()` request error.
  * @fires `ajax:request:error`
  * properties: `{ request, error, submitter } = event.detail`
  */
function dispatchRequestError({ element, fetchRequest, request, error, submitter }) {
    dispatch.call(element, AJAX_EVENTS.ajaxRequestError, {
        detail: { element, fetchRequest, request, error, submitter }
    });
}
/**
  * @fires the `ajax:error` event which is a catchall for request + response errors.
  * { response, request?, error?, submitter } = event.detail
  */
function dispatchError(event) {
    if (event.defaultPrevented) {
        dispatchStopped(event);
        return;
    }
    dispatch.call(findTarget(event), AJAX_EVENTS.ajaxError, {
        detail: { ...event.detail }
    });
}
// This is only for when event.defaultPrevented() is called.
// if a user calls `event.detail.submission.cancel()`, that will be triggered separately.
function dispatchStopped(event) {
    dispatch.call(findTarget(event), AJAX_EVENTS.ajaxStopped, {
        detail: { ...event.detail }
    });
}
/**
  * dispatches a given event in the context of `element`
  */
function attachListeners(fn) {
    document[fn]('submit', startFormSubmission); // fires ajaxBefore
    document[fn](AJAX_EVENTS.ajaxBefore, startFetchRequest); // fires ajaxBeforeSend
    // fires ajaxRequestError || ajaxSuccess || ajaxResponse
    document[fn](AJAX_EVENTS.ajaxBeforeSend, sendFetchRequest);
    document[fn](AJAX_EVENTS.ajaxSuccess, dispatchComplete);
    document[fn](AJAX_EVENTS.ajaxRequestError, dispatchError);
    document[fn](AJAX_EVENTS.ajaxResponseError, dispatchError);
    document[fn](AJAX_EVENTS.ajaxError, dispatchComplete);
}
function findTarget(event) {
    return event.target;
}
function shouldNotSubmit(element) {
    return (element === null || element === void 0 ? void 0 : element.dataset.ujsSubmit) === 'false';
}

function RemoteWatcher() {
    let query;
    function initialize() {
        query = window.mrujs.remoteSelector;
    }
    function connect() {
        $$1(query).forEach((el) => {
            addTurboFalse(el);
        });
    }
    function disconnect() { }
    function observerCallback(nodeList) {
        nodeList.forEach((node) => {
            if (matches$1(node, window.mrujs.remoteSelector)) {
                addTurboFalse(node);
            }
            if (node instanceof Element) {
                node.querySelectorAll(query).forEach((el) => {
                    addTurboFalse(el);
                });
            }
        });
    }
    return {
        name: 'RemoteWatcher',
        initialize,
        connect,
        disconnect,
        observerCallback
    };
}
function addTurboFalse(el) {
    if (el == null)
        return;
    if (el.getAttribute('data-turbo') != null)
        return;
    el.setAttribute('data-turbo', 'false');
}

function ClickHandler() {
    const callbacks = [preventInsignificantClick$1];
    let queries = [];
    function initialize() {
        queries = getQueries$4();
    }
    function connect() {
        addListeners(queries, callbacks);
    }
    function disconnect() {
        removeListeners(queries, callbacks);
    }
    function observerCallback(nodeList) {
        attachObserverCallback(queries, nodeList, callbacks);
    }
    return {
        name: 'ClickHandler',
        initialize,
        connect,
        disconnect,
        observerCallback,
        queries,
        callbacks
    };
}
function getQueries$4() {
    const { linkClickSelector, buttonClickSelector, formInputClickSelector } = window.mrujs;
    return [
        {
            event: 'click',
            selectors: [
                linkClickSelector,
                buttonClickSelector,
                formInputClickSelector
            ]
        }
    ];
}

function Confirm() {
    const callbacks = [handleConfirm$1];
    let queries = [];
    function initialize() {
        queries = getQueries$3();
    }
    function connect() {
        addListeners(queries, callbacks);
    }
    function disconnect() {
        removeListeners(queries, callbacks);
    }
    function observerCallback(nodeList) {
        attachObserverCallback(queries, nodeList, callbacks);
    }
    return {
        name: 'Confirm',
        initialize,
        connect,
        disconnect,
        observerCallback,
        queries,
        callbacks
    };
}
function handleConfirm$1(event) {
    if (!allowAction(event)) {
        stopEverything$1(event);
    }
}
function allowAction(event) {
    if (event.currentTarget == null)
        return true;
    const element = event.currentTarget;
    const message = element.dataset.confirm;
    if (message == null)
        return true;
    let answer = false;
    try {
        answer = window.mrujs.confirm(message);
    }
    catch (e) {
        console.warn('The following error was encountered when calling: "mrujs.confirm"\n\n');
        console.error(e);
    }
    const firedEvent = dispatch.call(element, 'confirm:complete', { detail: { answer } });
    return answer && !firedEvent.defaultPrevented;
}
function getQueries$3() {
    const { linkClickSelector, buttonClickSelector, formInputClickSelector, inputChangeSelector, formSubmitSelector } = window.mrujs;
    return [
        {
            event: 'click',
            selectors: [
                linkClickSelector,
                buttonClickSelector,
                formInputClickSelector
            ]
        },
        {
            event: 'change',
            selectors: [
                inputChangeSelector
            ]
        },
        {
            event: 'submit',
            selectors: [
                formSubmitSelector
            ]
        }
    ];
}

/**
 * This class handles data-method / data-remote submissions (<a data-remote"true">)
  */
function MethodSubmission(element) {
    var _a, _b;
    const method = getElementMethod(element);
    let maskedMethod;
    if ((_a = window.mrujs) === null || _a === void 0 ? void 0 : _a.maskLinkMethods) {
        maskedMethod = getMaskedMethod(method);
    }
    const href = (_b = element.getAttribute('href')) !== null && _b !== void 0 ? _b : element.dataset.url;
    if (href == null) {
        throw Error(`No 'href' or 'data-url' found on ${JSON.stringify(element)}`);
    }
    const url = expandUrl(href);
    const options = {
        headers: getHeaders(element)
    };
    options.method = maskedMethod !== null && maskedMethod !== void 0 ? maskedMethod : method;
    if (!isGetRequest(method))
        options.body = getBody(method, element);
    const fetchRequest = FetchRequest$1(url, options);
    return {
        request: fetchRequest.request,
        fetchRequest
    };
}
/**
 * Headers to send to the request object
 */
function getHeaders(element) {
    let responseType;
    if (element != null) {
        responseType = element.dataset.type;
    }
    const acceptHeader = findResponseTypeHeader(responseType);
    const headers = new Headers({ Accept: acceptHeader });
    headers.set('Accept', acceptHeader);
    return headers;
}
/**
  * Returns properly built FormData
  */
function getFormData(method) {
    var _a;
    const formData = new FormData();
    if ((_a = window.mrujs) === null || _a === void 0 ? void 0 : _a.maskLinkMethods) {
        formData.append('_method', method);
    }
    return formData;
}
/**
  * Finds how to send the fetch request
  * get, post, put, patch, etc
  */
function getElementMethod(element) {
    var _a;
    const method = (_a = element.dataset.method) !== null && _a !== void 0 ? _a : 'get';
    return method.toLowerCase();
}
/**
  * If its a get request, leave it, everything else is masked as a POST.
  */
function getMaskedMethod(method) {
    return isGetRequest(method) ? 'get' : 'post';
}
function getBody(method, element) {
    const encodedFormData = urlEncodeFormData(getFormData(method));
    // add input's name and value to submission
    const elName = element.getAttribute('name');
    // cast to HTMLInputElement to make TS happy.
    const elValue = element.value;
    if (elName != null && elValue != null)
        encodedFormData.append(elName, elValue);
    const additionalParams = parseParams(element.getAttribute('data-params'));
    if (additionalParams == null)
        return encodedFormData;
    for (const [key, value] of additionalParams) {
        if (value == null)
            continue;
        const val = value.toString();
        // Only strings can be added to UrlSearchParams
        const isString = (typeof val === 'string' || val instanceof String);
        if (!isString)
            continue;
        encodedFormData.append(key, val.toString());
    }
    return encodedFormData;
}
function parseParams(params) {
    if (params == null)
        return undefined;
    // convert encoded params to decoded params
    if (containsEncodedComponents(params)) {
        params = decodeURIComponent(params);
    }
    // json format
    try {
        return Object.entries(JSON.parse(params));
    }
    catch (_a) { }
    // param string format
    try {
        return new URLSearchParams(params).entries();
    }
    catch (_b) { }
    return undefined;
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent
function containsEncodedComponents(x) {
    // ie ?,=,&,/ etc
    return (decodeURI(x) !== decodeURIComponent(x));
}

/**
 * Handles `data-method="method"` submissions.
 */
function Method() {
    const callbacks = [handleMethod$1];
    let queries = [];
    function initialize() {
        queries = getQueries$2();
    }
    function connect() {
        addListeners(queries, callbacks);
    }
    function disconnect() {
        removeListeners(queries, callbacks);
    }
    function observerCallback(nodeList) {
        attachObserverCallback(queries, nodeList, callbacks);
    }
    return {
        name: 'Method',
        initialize,
        connect,
        disconnect,
        observerCallback,
        queries,
        callbacks
    };
}
/**
  * Handles "data-method" on <a> tags such as:
  * @example
  *   // Not implemented!
  *   <a href="/users/5" data-method="delete" rel="nofollow" data-confirm="Are you sure?">Delete</a>
  *
  *   // Implemented!
  *   <a href="/users/5" data-method="delete" rel="nofollow">Delete</a>
  */
function handleMethod$1(event) {
    var _a;
    const element = event.currentTarget;
    if (element.dataset.remote === 'false')
        return;
    if (element.dataset.method == null && element.dataset.remote !== 'true')
        return;
    // no href or url? Do not pass go.
    const href = (_a = element.getAttribute('href')) !== null && _a !== void 0 ? _a : element.dataset.url;
    if (href == null)
        return;
    event.preventDefault();
    const submitter = event.target;
    const linkSubmission = MethodSubmission(element);
    const { fetchRequest, request } = linkSubmission;
    /**
      * Send it through the event chain. use ajax:beforeSend because submit auto
      * populates fields that we dont want.
      */
    dispatch.call(element, AJAX_EVENTS.ajaxBeforeSend, {
        detail: { element, fetchRequest, request, submitter }
    });
}
function getQueries$2() {
    const { linkClickSelector, inputChangeSelector, buttonClickSelector } = window.mrujs;
    return [
        {
            event: 'click',
            selectors: [
                linkClickSelector,
                buttonClickSelector
            ]
        },
        {
            event: 'change',
            selectors: [
                inputChangeSelector
            ]
        }
    ];
}

const ALLOWABLE_ACTIONS = [
    'advance',
    'replace',
    'restore'
];
function NavigationAdapter() {
    const obj = {
        name: 'NavigationAdapter',
        connect: connect$1,
        disconnect: disconnect$1,
        cacheContains,
        prefetch,
        navigate
    };
    Object.defineProperties(obj, {
        adapter: { get: function () { return findAdapter(); } },
        snapshotCache: { get: function () { return findSnapshotCache(findAdapter()); } }
    });
    return obj;
}
function connect$1() {
    document.addEventListener('ajax:complete', beforeNavigation);
    document.addEventListener('ajax:beforeNavigation', navigateViaEvent);
}
function disconnect$1() {
    document.removeEventListener('ajax:complete', beforeNavigation);
    document.removeEventListener('ajax:beforeNavigation', navigateViaEvent);
}
function beforeNavigation(event) {
    if (event.defaultPrevented)
        return;
    dispatch.call(event.detail.element, 'ajax:beforeNavigation', { detail: { ...event.detail } });
}
function findAdapter() {
    if (useTurbolinks())
        return window.Turbolinks;
    if (useTurbo())
        return window.Turbo;
    return undefined;
}
function useTurbolinks() {
    if (window.Turbolinks == null)
        return false;
    if (window.Turbolinks.supported !== true)
        return false;
    return true;
}
function useTurbo() {
    if (window.Turbo == null)
        return false;
    return true;
}
function prefetch({ html, url }) {
    const expandedUrl = expandUrl(url);
    const snapshot = generateSnapshotFromHtml(html);
    putSnapshotInCache(expandedUrl, snapshot);
}
function findSnapshotCache(adapter) {
    if (adapter == null)
        return undefined;
    if (useTurbolinks())
        return adapter.controller.cache;
    if (useTurbo())
        return adapter.navigator.view.snapshotCache;
    return undefined;
}
function cacheContains(url) {
    var _a;
    const expandedUrl = expandUrl(url);
    const snapshotCache = findSnapshotCache(findAdapter());
    return (_a = snapshotCache === null || snapshotCache === void 0 ? void 0 : snapshotCache.has(expandedUrl)) !== null && _a !== void 0 ? _a : false;
}
/**
  * Currently, this only fires on successful form submissions.
  */
function navigateViaEvent(event) {
    if (event.defaultPrevented)
        return;
    const { element, fetchResponse, fetchRequest } = event.detail;
    if (!shouldNavigate(element, fetchResponse))
        return;
    navigate(element, fetchRequest, fetchResponse);
}
function shouldNavigate(element, fetchResponse) {
    if (element.dataset.ujsNavigate === 'false')
        return false;
    if (fetchResponse == null)
        return false;
    // Only render / navigate responses on html responses.
    if (!fetchResponse.isHtml)
        return false;
    if (element instanceof HTMLFormElement && fetchResponse.succeeded && !fetchResponse.redirected) {
        console.error('Successful form submissions must redirect');
        return false;
    }
    return true;
}
/**
  * This is a manual navigation triggered by something like `method: :delete`
  */
function navigate(element, request, response, action) {
    // If we get redirected, use Turbolinks
    // This needs to be reworked to not trigger 2 HTML responses or find a
    // way to not refetch a page.
    action = action !== null && action !== void 0 ? action : determineAction(element);
    let location = expandUrl(window.location.href);
    if (request === null || request === void 0 ? void 0 : request.isGetRequest)
        location = request.url;
    if (response.redirected)
        location = response.location;
    const currentLocation = window.location.href;
    const isSamePage = urlsAreEqual(location, currentLocation);
    let errorRenderer = 'morphdom';
    if (window.mrujs.errorRenderer === 'turbo' || element.getAttribute('data-ujs-error-renderer') === 'turbo') {
        errorRenderer = 'turbo';
    }
    if (response.failed || isSamePage) {
        // Use morphdom to dom diff the response if the response is HTML.
        morphResponse(element, response, !isSamePage, errorRenderer);
        return;
    }
    const adapter = findAdapter();
    if (adapter == null) {
        morphResponse(element, response, isSamePage, errorRenderer);
        return;
    }
    adapter.clearCache();
    // Special navigation handling for Turbo[links].
    preventDoubleVisit(response, location, action);
}
function putSnapshotInCache(location, snapshot) {
    if (snapshot === '')
        return;
    const snapshotCache = findSnapshotCache(findAdapter());
    snapshotCache === null || snapshotCache === void 0 ? void 0 : snapshotCache.put(expandUrl(location), snapshot);
}
function generateSnapshotFromHtml(html) {
    var _a, _b, _c;
    const adapter = findAdapter();
    if (adapter == null)
        return '';
    if (useTurbolinks()) {
        return (_a = adapter.Snapshot.wrap(html)) !== null && _a !== void 0 ? _a : '';
    }
    if (useTurbo() && canSnapshot()) {
        return (_c = (_b = adapter.PageSnapshot) === null || _b === void 0 ? void 0 : _b.fromHTMLString(html)) !== null && _c !== void 0 ? _c : '';
    }
    return '';
}
function canSnapshot() {
    const adapter = findAdapter();
    if (adapter == null)
        return false;
    if (useTurbolinks())
        return true;
    if (useTurbo()) {
        // PageSnapshot is required in Turbo to manually generate Snapshots.
        if (adapter.PageSnapshot == null) {
            console.warn('The version of Turbo you are currently using does not support ' +
                'snapshot generation. Please consider upgrading your version of Turbo.');
            return false;
        }
        return true;
    }
    return false;
}
function preventDoubleVisit(response, location, action) {
    const adapter = findAdapter();
    if (adapter == null)
        return;
    // This is a fun wrapper to avoid double visits with Turbolinks
    response.html().then((html) => {
        prefetch({ html, url: location });
        action = 'restore';
        adapter.visit(location, { action });
    }).catch((error) => console.error(error));
}
function morphResponse(element, response, pushState = false, errorRenderer = 'morphdom') {
    // Dont pass go if its not HTML.
    if (!response.isHtml)
        return;
    response.html()
        .then((html) => {
        var _a;
        if (errorRenderer === 'turbo') {
            renderError(html);
        }
        else if (errorRenderer === 'morphdom') {
            const selectorString = element.getAttribute('data-ujs-morph-root');
            let selector = document.body;
            if (selectorString != null) {
                if (selectorString.trim() === '') {
                    selector = element;
                }
                else {
                    selector = (_a = document.querySelector(selectorString)) !== null && _a !== void 0 ? _a : document.body;
                }
            }
            morphHtml(html, selector);
        }
        if (pushState) {
            // https://developer.mozilla.org/en-US/docs/Web/API/History/pushState
            window.history.pushState({}, '', response.location);
        }
    })
        .catch((error) => {
        console.error(error);
    });
}
function morphHtml(html, selector = document.body) {
    const template = document.createElement('template');
    template.innerHTML = String(html).trim();
    morphdom(selector, template.content, { childrenOnly: true });
}
function renderError(html) {
    const adapter = findAdapter();
    adapter === null || adapter === void 0 ? void 0 : adapter.navigator.view.renderError(generateSnapshotFromHtml(html));
}
function determineAction(element) {
    var _a, _b;
    let action = (_b = (_a = element.dataset.turbolinksAction) !== null && _a !== void 0 ? _a : element.dataset.turboAction) !== null && _b !== void 0 ? _b : 'advance';
    if (!ALLOWABLE_ACTIONS.includes(action)) {
        action = 'advance';
    }
    return action;
}

function DisabledElementChecker() {
    const callbacks = [handleDisabledElement$1];
    let queries = [];
    function initialize() {
        queries = getQueries$1();
    }
    function connect() {
        addListeners(queries, callbacks);
    }
    function disconnect() {
        removeListeners(queries, callbacks);
    }
    function observerCallback(nodeList) {
        attachObserverCallback(queries, nodeList, callbacks);
    }
    return {
        name: 'DisabledElementChecker',
        initialize,
        connect,
        disconnect,
        observerCallback,
        queries,
        callbacks
    };
}
function getQueries$1() {
    const { linkClickSelector, buttonClickSelector, inputChangeSelector, formSubmitSelector, formInputClickSelector } = window.mrujs;
    return [
        { event: 'click', selectors: [buttonClickSelector, linkClickSelector, formInputClickSelector] },
        { event: 'change', selectors: [inputChangeSelector] },
        { event: 'submit', selectors: [formSubmitSelector] }
    ];
}
function handleDisabledElement$1(event) {
    if (this.disabled === true)
        stopEverything$1(event);
}

function ElementEnabler() {
    const callbacks = [enableElement$1];
    let queries = [];
    function initialize() {
        queries = getQueries();
    }
    function connect() {
        addListeners(queries, callbacks);
    }
    function disconnect() {
        removeListeners(queries, callbacks);
    }
    function observerCallback(nodeList) {
        attachObserverCallback(queries, nodeList, callbacks);
    }
    return {
        name: 'ElementEnabler',
        initialize,
        connect,
        disconnect,
        observerCallback,
        callbacks
    };
}
function getQueries() {
    const { formSubmitSelector, buttonDisableSelector, linkDisableSelector, inputChangeSelector } = window.mrujs;
    const selectors = [linkDisableSelector, buttonDisableSelector,
        formSubmitSelector, inputChangeSelector];
    return [
        { event: AJAX_EVENTS.ajaxComplete, selectors: selectors },
        { event: AJAX_EVENTS.ajaxStopped, selectors: selectors },
        { event: 'turbo:submit-end', selectors: selectors }
    ];
}
// Unified function to enable an element (link, button and form)
function enableElement$1(trigger) {
    let element = trigger;
    if (trigger instanceof Event)
        element = trigger.target;
    const { linkDisableSelector, buttonDisableSelector, formEnableSelector, formSubmitSelector } = window.mrujs;
    if (matches$1(element, linkDisableSelector)) {
        enableLinkElement(element);
        return;
    }
    if (matches$1(element, buttonDisableSelector) || matches$1(element, formEnableSelector)) {
        enableFormElement(element);
        return;
    }
    if (matches$1(element, formSubmitSelector)) {
        enableFormElements(element);
    }
}
/**
  * Restore element to its original state which was disabled by 'disableLinkElement' above
  */
function enableLinkElement(element) {
    const originalText = element.dataset.ujsEnableWith;
    if (originalText != null) {
        element.innerHTML = originalText; // set to old enabled state
        element.removeAttribute('data-ujs-enable-with'); // clean up cache
    }
    element.removeEventListener('click', stopEverything$1); // enable element
    element.removeAttribute('data-ujs-disabled');
}
/**
 * Re-enables disabled form elements:
 *  - Replaces element text with cached value from 'ujs-enable-with' data store (created in `disableFormElements`)
 *  - Sets disabled property to false
 */
function enableFormElements(form) {
    const elements = formElements$1(form, window.mrujs.formEnableSelector);
    elements.forEach(enableFormElement);
}
function enableFormElement(element) {
    const originalText = element.dataset.ujsEnableWith;
    if (originalText != null) {
        if (matches$1(element, 'button')) {
            element.innerHTML = originalText;
        }
        else {
            element.value = originalText;
        }
        element.removeAttribute('data-ujs-enable-with'); // clean up cache
    }
    element.disabled = false;
    element.removeAttribute('data-ujs-disabled');
}

/**
 * Mutation observer for added nodes.
 */
function AddedNodesObserver(callback) {
    const observer = new MutationObserver(callback);
    function connect() {
        observer.observe(document, { childList: true, subtree: true, attributes: true });
    }
    function disconnect() {
        observer.disconnect();
    }
    return {
        name: 'AddedNodesObserver',
        connect,
        disconnect
    };
}

function Mrujs(obj = {}) {
    var _a;
    obj.connected = false;
    obj = { ...BASE_SELECTORS };
    obj.FetchResponse = FetchResponse$1;
    obj.FetchRequest = FetchRequest$1;
    obj.addedNodesObserver = AddedNodesObserver(addedNodesCallback);
    obj.remoteWatcher = RemoteWatcher();
    obj.elementEnabler = ElementEnabler();
    obj.elementDisabler = ElementDisabler();
    obj.disabledElementChecker = DisabledElementChecker();
    obj.navigationAdapter = NavigationAdapter();
    obj.clickHandler = ClickHandler();
    obj.confirmClass = Confirm();
    obj.csrf = Csrf();
    obj.method = Method();
    obj.formSubmitDispatcher = FormSubmitDispatcher();
    // Order matters here!
    const corePlugins = [
        obj.addedNodesObserver,
        obj.remoteWatcher,
        obj.csrf,
        obj.elementEnabler,
        obj.clickHandler,
        obj.disabledElementChecker,
        obj.confirmClass,
        obj.elementDisabler,
        obj.method,
        obj.formSubmitDispatcher,
        obj.navigationAdapter
    ];
    obj.corePlugins = corePlugins;
    const plugins = (_a = obj.plugins) !== null && _a !== void 0 ? _a : [];
    obj.plugins = plugins;
    const allPlugins = corePlugins.concat(plugins);
    obj.allPlugins = allPlugins;
    obj.maskLinkMethods = true;
    obj.mimeTypes = { ...BASE_ACCEPT_HEADERS };
    obj.stop = stop;
    obj.restart = restart;
    obj.fetch = fetch;
    obj.urlEncodeFormData = urlEncodeFormData;
    obj.registerMimeTypes = registerMimeTypes;
    obj.enableElement = enableElement$1;
    obj.enableFormElements = enableFormElements;
    obj.enableFormElement = enableFormElement;
    obj.disableElement = disableElement$1;
    obj.stopEverything = stopEverything$1;
    obj.dispatch = dispatch;
    obj.addListeners = addListeners;
    obj.removeListeners = removeListeners;
    obj.attachObserverCallback = attachObserverCallback;
    obj.expandUrl = expandUrl;
    obj.findSubmitter = findSubmitter;
    // a wrapper for document.querySelectorAll
    obj.$ = $$1;
    obj.CSRFProtection = CSRFProtection$1;
    obj.csrfParam = csrfParam$1;
    obj.csrfToken = csrfToken$1;
    obj.cspNonce = cspNonce$1;
    obj.confirm = confirm$1;
    obj.handleConfirm = handleConfirm$1;
    obj.handleDisabledElement = handleDisabledElement$1;
    obj.handleMethod = handleMethod$1;
    obj.start = start$1;
    obj.preventInsignificantClick = preventInsignificantClick$1;
    obj.refreshCSRFTokens = refreshCSRFTokens$1;
    obj.delegate = delegate$1;
    obj.fire = fire$1;
    obj.formElements = formElements$1;
    obj.matches = matches$1;
    obj.toArray = toArray;
    return obj;
}
function start$1(options = {}) {
    var _a;
    window.Rails = window.mrujs = this;
    // Dont start twice!
    if (window.mrujs.connected) {
        return window.mrujs;
    }
    Object.assign(this, options);
    this.allPlugins = this.corePlugins.concat(this.plugins);
    for (let i = 0; i < this.allPlugins.length; i++) {
        const plugin = this.allPlugins[i];
        (_a = plugin.initialize) === null || _a === void 0 ? void 0 : _a.call(plugin);
    }
    connect();
    return this;
}
function stop() {
    disconnect();
}
function restart() {
    disconnect();
    connect();
}
function connect() {
    var _a;
    // This event works the same as the load event, except that it fires every
    // time the page is loaded.
    // See https://github.com/rails/jquery-ujs/issues/357
    // See https://developer.mozilla.org/en-US/docs/Using_Firefox_1.5_caching
    reEnableDisabledElements();
    window.addEventListener('pageshow', reEnableDisabledElements);
    for (let i = 0; i < window.mrujs.allPlugins.length; i++) {
        const plugin = window.mrujs.allPlugins[i];
        (_a = plugin.connect) === null || _a === void 0 ? void 0 : _a.call(plugin);
    }
    window.mrujs.connected = true;
}
function disconnect() {
    var _a;
    window.removeEventListener('pageshow', reEnableDisabledElements);
    for (let i = 0; i < window.mrujs.allPlugins.length; i++) {
        const plugin = window.mrujs.allPlugins[i];
        (_a = plugin.disconnect) === null || _a === void 0 ? void 0 : _a.call(plugin);
    }
    window.mrujs.connected = false;
}
function confirm$1(message) {
    return window.confirm(message);
}
function addedNodesCallback(mutationList, _observer) {
    for (const mutation of mutationList) {
        let addedNodes;
        if (mutation.type === 'attributes') {
            addedNodes = [mutation.target];
        }
        else {
            addedNodes = Array.from(mutation.addedNodes);
        }
        // kick it into setTimeout so we dont delay rendering
        window.setTimeout(() => {
            var _a;
            for (let i = 0; i < window.mrujs.allPlugins.length; i++) {
                const plugin = window.mrujs.allPlugins[i];
                (_a = plugin.observerCallback) === null || _a === void 0 ? void 0 : _a.call(plugin, addedNodes);
            }
        }, 0);
    }
}
function fetch(input, options = {}) {
    let { element, submitter, dispatchEvents } = options;
    delete options.element;
    delete options.submitter;
    delete options.dispatchEvents;
    const fetchRequest = FetchRequest$1(input, options);
    if (dispatchEvents === true) {
        if (element == null)
            element = document.documentElement;
        dispatch.call(element, AJAX_EVENTS.ajaxBeforeSend, {
            detail: { element, fetchRequest, request: fetchRequest.request, submitter }
        });
        return undefined;
    }
    return window.fetch(fetchRequest.request);
}
function registerMimeTypes(mimeTypes) {
    mimeTypes.forEach((mimeType) => {
        const { shortcut, header } = mimeType;
        window.mrujs.mimeTypes[shortcut] = header;
    });
    return window.mrujs.mimeTypes;
}
function reEnableDisabledElements() {
    const { formEnableSelector, linkDisableSelector } = window.mrujs;
    $$1(`${formEnableSelector}, ${linkDisableSelector}`)
        .forEach(element => {
        const el = element;
        // Reenable any elements previously disabled
        enableElement$1(el);
    });
}
function cspNonce$1() {
    return getMetaContent('csp-nonce');
}

// Currently only import the safari submit event polyfill.
const mrujs = Mrujs();
// Yay...esmodules!
const { $, CSRFProtection, buttonClickSelector, buttonDisableSelector, cspNonce, csrfParam, csrfToken, confirm, delegate, disableElement, enableElement, fileInputSelector, fire, formDisableSelector, formElements, formEnableSelector, formInputClickSelector, formSubmitSelector, handleConfirm, handleDisabledElement, handleMethod, inputChangeSelector, linkClickSelector, linkDisableSelector, matches, preventInsignificantClick, refreshCSRFTokens, start, stopEverything, FetchResponse, FetchRequest } = mrujs;

export { $, CSRFProtection, FetchRequest, FetchResponse, Mrujs, buttonClickSelector, buttonDisableSelector, confirm, cspNonce, csrfParam, csrfToken, mrujs as default, delegate, disableElement, enableElement, fileInputSelector, fire, formDisableSelector, formElements, formEnableSelector, formInputClickSelector, formSubmitSelector, handleConfirm, handleDisabledElement, handleMethod, inputChangeSelector, linkClickSelector, linkDisableSelector, matches, mrujs, preventInsignificantClick, refreshCSRFTokens, start, stopEverything };
//# sourceMappingURL=index.module.js.map
